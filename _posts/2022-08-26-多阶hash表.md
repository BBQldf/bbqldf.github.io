---
layout:     post
title:     多人音视频项目优化
subtitle:   基础知识、扩展学习
date:       2022-08-26
author:     ldf
header-img: img/post-bg-code01.png
catalog: true
tags:
    - 数据结构基础
    - 编程基础
---


# 多阶hash表

> 不少同学对哈希问题都还停留在课本中的知识中，对实际工程中的实现了解甚少。[多阶哈希](https://www.bilibili.com/video/BV1cr4y1V73K?share_source=copy_web)就是一个非常经典的实现案例。
>
> 这个就是突出差别的地方！也是在tx后台看到的一种解决方案；背景：统计hash表的使用阶数`StatHashIndex();`
>
> 与之相关的还有一个CuckooHashing表，但是有点不同的是，CuckooHashing表会在插入失败的时候踢出原来的元素，然后重新插入；

多阶hash表结构示意图：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220704120931.png)

宏观上看：

1. 整体上看多阶哈希可以视作一个二维数组(或者链表数组，这和实现相关)，第一维是hash桶的编号，第二维是每阶桶的个数。
2. 实际申请内存时，可以是一块连续的内存，用每次层的阶数来标识出不同阶的分界(为了最大化利用存储，直接采用每阶的素数作为每阶的桶数)。

3. 优势：
   - 实现简单，并且有很好的扩展性(如以多阶哈希为内存核心的分布式缓存系统)。
   - 一维线性空间，在存储时处理(dump/reload)简单。
   - 纯内存操作,极高的读写性能。
   - 有多个桶，使得空间利用率很高，你多阶哈希并不需要一个很大的桶来减少冲突。16阶可达到80%以上，32阶可达到90%。
4. 缺点：
   1. 如内存块大小固定（初始化时占用空间很大）
   2. 容量瓶颈到了不容易扩展等等。（扩容是容易的，但是扩容之后的效果可能并不是特别好，因为）



微观上看：

1. 每一行是一阶，上面的元素个数多，下面的元素个数依次减少. 每一行的元素个数都是素数。其中，节点的前四个字节用来存储int类型的Key或者是hash_code.
2. 创建多阶HASH的时候，用户通过参数来指定有多少阶，每一阶做最多有多少个元素.
   - 采用了素数集中原理的算法来查找。假如每阶最多有1000个元素，一共10阶，则算法选择十个比1000小的最大素数，从大到小排列，以此作为各阶的元素个数. 通过素数集中的算法得到的10个素数分别是： 997 991 983 977 971 967 953 947 941 937. 可见虽然是锯齿数组，各层之间的差别并不是很多。——（网上很多这种说法，其实是不准确的，最佳实践是各层空间按指数数列排序；只不过这种操作很简单）

## 增删改查

> 主要优点在于扩容的操作更加方便。然后处理hash冲突的方式不同，导致其查找和插入的方式也不同

**查找：**

先将key在第一阶内取模，看是否是这个元素，如果这个位置为空，直接返回不存在; 如果是这个key，则返回这个位置；如果这个位置有元素，但是又不是key，则说明hash冲突了，再去第二阶去寻找. 循环往复.（只有hash冲突的时候才会进入下一阶）

**插入**

插入的时候，如果没有发生哈希冲突，那么照常插入。如果一旦发生哈希冲突，那么就在下一阶进行插入判断。

**增容**

但是一旦需要增容的时候，多阶哈希的优点就体现出来了。不论是开散列还是闭散列，在增容的时候都需要开辟一片更大的空间，并且将之前空间内的数据全部进行从新计算并拷贝，这个过程是一个非常耗费时间与空间的过程，并低效！**而多阶哈希在增容时只需要再多增加一阶哈希表即可，并不需要对之前的所有数据进行搬运，这就能够节省很大的效率。**

**与传统的hash桶数据结构相比：**

1. 

- **优势：**在增容问题上，多阶hash更加轻量
- **缺点：**初始化的时候，哈希桶是来一个插入一个，对空间的利用率很高，并不会浪费很多空间。而多阶哈希在创建时就需要开辟一大段空间。（所以多阶hash更加适合大数量级）
  - 特别是多阶hash的下面阶层，基本不会被用到；所以一个好的实践是，各层空间按指数数列排序

## **解决hash冲突：**

> 碰撞处理方法实现上各异，这里提供一种多阶的线性探测实现方法。

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220704144859.png)



**解决极端情况无法插入问题：**

在多阶哈希表内有很多元素的时候，此时插入新的数据，发现每阶哈希都发生哈希冲突无法插入，那么这个时候如何解决？——采用类似扩容的方法，再创建一阶哈希表进行存储；（因为出现这种情况，一般是已经有很多元素了）

但是，还有一种理论情况，十阶哈希插入十一个元素，插入完毕前十个元素后，从第十一元素开始跟前十阶都发生哈希冲突，此时如果开辟一阶新的哈希表是不是代价就有点大了。那么如何解决？——将多阶哈希与开散列哈希桶相结合使用（前9阶还是常规hash方案，但是最后一阶采用hash桶结构）——这种就不常用，因为要改数据结构，没必要~

上面这是一种，但是可操作性差，**我们可以使用cuckoo hash在插入失败的情况下做优化，**其他情况保持不变，即：

1. 假设多阶哈希总阶数为N，要插入的数据为K1
2. 若插入失败，则指定以下流程
   a ) 在N/3到N/2的(即不满的阶)的阶，随机选择一阶N1
   b ) 将K1插入N1阶，踢出原位的K2
   c ) 对K2从N1开始重新执行哈希插入，直至插入成功。否则，重试2.a

如此，就**可以延迟插入失败，提高多阶哈希的装载率**。



额外说一下，**传统的开放定址法**通过使用某种探测算法在散列表中寻找下一个空的散列地址，存在一个问题：——**墓碑机制**

- 开放定址法在删除的时候会比较复杂，因为如果直接删除会造成空表项，那么便可能会分割冲突后的位置和其原位置（原位置在空表项前，探测的位置在空表项后），所以需要墓碑。
  - 举个例子：如果一个值为E在桶中碰撞到了A——C——D，我把E放到D之后；如果要删掉C，并不能直接删掉，而是留一个墓碑；不然的话，A之后就断掉了，找不到D了（因为D也是和A碰撞的元素）。
  - **这里的墓碑元素也就是大家经常讨论的ThreadLocal存内存泄露的根本所在。**该元素变成墓碑了，但是他的Value仍然持有内存，且暂时不会释放（弱引用），这就导致了内存泄露。

![墓碑机制](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220704151650.png)



## 为什么要用不同的质数作为表的大小？

> 这个问题有两个层面：1.为什么要用质数？2. 为什么要不同？

### 为什么要用质数？

其实也不一定；但是层与层之间最好是互质的。因为多层hash的目的是：在hash冲突的时候，从第一层到第二层的映射不一样。（比如CuckooHashing在每一层用不同的hash函数；hash值每次都伪随机一下（rehash思想））。

- 但是，要真正做到每一层hash函数之后，数据是完全没有相关性的？不好设计，还不如两两互质



### 为什么要不同？

如果每一层的大小都是一样的，那么两层之间的hash结构是类似的，也就是相关性很高；比如，用同一个hash值去模10，那无论在哪一层，都是一样的情况。即，第二层的第三个位置有填充，那第一层的第三个位置肯定是有填充的。



## [为什么腾讯会选择这个数据结构](https://www.bilibili.com/video/BV1cr4y1V73K?share_source=copy_web)？

为什么采用?

- 静态连续空间
- 实现简单
- 并发访问

在腾讯，后台架构上是数据-逻辑分离的。也就是说进程逻辑本身是不会保存数据的。以下面的图来解释，P1和P2是两个进程，他们的数据其实都放在共享内存中（SHM），或者是在磁盘上开一个文件。他们都有一个特点，就是都是一大段连续的空间，如果这个时候我们去用多阶hash的话，就可以节省开发成本（因为实现很简单，并且性能也有保证）。共享内存也有个好处，就是可以支持**单写多读**。——（这里又涉及到了并发的问题，比如用CAS操作来判断一个数据是不是我要操作的数据）

那至于为什么腾讯要把数据-逻辑分开，主要还是稳定性的考虑。比如，进程跑着跑着挂了，被杀了，他的数据还是在内存中的。

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220704150503.png)



## CuckooHashing表

**cuckoo hash是一种解决hash冲突的方法**（注意这句话，就点名这个是一种算法思想），其目的是使用简单的hash 函数来提高hash table的利用率，同时保证O(1)的查询时间

基本思想是使用2个hash函数来处理碰撞，从而每个key都对应到2个位置。

插入操作如下：

1. 对key值hash，生成两个hash key值，hashk1和 hashk2, 如果对应的两个位置上有一个为空，那么直接把key插入即可。

2. 否则，任选一个位置，把key值插入，把已经在那个位置的key值踢出来。

3. 被踢出来的key值，需要重新插入，直到没有key被踢出为止。
   - 如果一直有key被踢，那么直到被踢的次数达到一个上限，就确认哈希表已满，并执行rehash操作。
