---
layout:     post
title:     CGo学习-Cgo编译Login_client
subtitle:   扩展学习
date:       2022-08-01
author:     ldf
header-img: img/post-bg-cgo01.png
catalog: true
tags:
    - CGo
    - 开发技巧
    - 跨语言编译
---
## 1、Cgo编译Login_client

### 项目背景

qq_login_push项目依靠上游login_client服务提供用户上线队列；login_client服务提供了两个主要功能：

- login_recv，用于从上游login_client服务中获取到用户上线的信息，并存放在本地的共享内存中；
- login_query，用于从共享内存中拿取一条用户信息（循环调用）

login_recv只要本机安装运行login_client，这个程序就会不断去接收数据；而login_query才是业务真正调用的SDK。问题是，api/login_query.h是C++的，如果服务要用go语言得自己通过Cgo的方式调用。

login_query.h：

```c++
#include "login_record.pb.h"

using im::server::sync_login::LoginRecord;		//导入LoginRecord类

//注意：以下API只支持单线程环境

//初始化，只能运行一次
//return: 0-succ, else-error
int LoginQuery_Init();

//获取一条上下线记录
//return: 0-succ, 1-empty, else-error
int LoginQuery_Get(LoginRecord & record);

//根据ret返回错误信息
//ret: 上次API调用的返回值
const char * LoginQuery_ErrMsg(int ret);
```

可以看到，login_query.h为查询用户上线数据队列提供了三个SDK。并依赖了login_record.pb.h，导入了LoginRecord类；

按照Cgo的调用方式编辑好go的调用代码、C++的函数声明包裹、C++的函数实现：

- query_get.go

```
// LoginQuery_Get 获取一条上下线记录
func AvLoginQuery_Get(ctx context.Context) (*login_record.LoginRecord, error) {
	valueAddress := make([]byte, AVMAXLEN)
	avRecord_Rsp := &login_record.LoginRecord{}
	res := C.AvLoginQuery_Get((*C.char)(unsafe.Pointer(&valueAddress[0])), C.int(AVMAXLEN))
	if res > 1 {
		//反序列化数据
		if err := proto.Unmarshal(valueAddress[:res], avRecord_Rsp); err != nil {
			metrics.IncrCounter("Cgo query_get-反序列化数据失败", 1)
			log.ErrorContextf(ctx, "Cgo query_get-Unmarshal error:%+v", err)
			return avRecord_Rsp, err
		}
		metrics.IncrCounter("Query_get success", 1)
		log.DebugContextf(ctx, "反序列化后数据:%+v", avRecord_Rsp)
		return avRecord_Rsp, nil
	} else if res == 1 {
		metrics.IncrCounter("QueryGet 空数据", 1)
		log.DebugContextf(ctx, "QueryGet Empty.") //未从队列拉到uin
		time.Sleep(1000 * time.Microsecond)
	} else {
		metrics.IncrCounter("QueryGet 出错", 1)
		log.ErrorContextf(ctx, "QueryGet Error. %d", res) //拉取队列出错
		time.Sleep(1000 * time.Microsecond)
	}
	return avRecord_Rsp, errors.New("未查询到数据")
}
```

- wrapper.h：

```c++
int AvLoginQuery_Init();

int AvLoginQuery_Get(char *avRecord, int avLen);
```

- wrapper.cpp

```c++
int AvLoginQuery_Init(){
    // init login client-------------------------------
   return LoginQuery_Init();
}

const char * AvLoginQuery_ErrMsg(int ret){
    return LoginQuery_ErrMsg(ret);
}



int AvLoginQuery_Get(char *avRecord, int avMaxLen)
{
    LoginRecord  record;
    int res = LoginQuery_Get(record);
    if(res == 0){
        //数据序列化
        auto str = record.SerializeAsString();
        //query_get返回包大于指定最大长度，则返回-1（失败）
        if(str.size() > avMaxLen){
            return -1;
        }
        //正常的数据包直接拷贝到预留的内存地址，返回0（成功）  
        memcpy(avRecord,str.c_str(),str.size());
        return str.size();
    }
    //query_get返回空数据包或者错误，返回值保持一致
    return -1;
}
```

调整好文件后（lib目录下**只**放需要静态库liblogin_query.a；include目录下**只**放函数SDK接口）：

```shell
├── login_client_go
│   ├── login_client_sdk
│   │   ├── include
│   │   │   └── login_query.h
│   │   └── lib
│   │       └── liblogin_query.a
│   ├── login_record.pb.cc
│   ├── login_record.pb.h
│   ├── login_record.proto
│   ├── query_get.go
│   ├── wrapper.cpp
│   └── wrapper.h
```

### 问题描述

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220731112046.png)

```shell
In file included from /usr/include/c++/4.8.2/mutex:35:0,
                 from /usr/local/include/google/protobuf/stubs/mutex.h:33,
                 from /usr/local/include/google/protobuf/stubs/common.h:52,
                 from ./login_client_sdk/include/login_record.pb.h:9,
                 from ./login_client_sdk/include/login_query_get.h:1,
                 from wrapper.cc:4:
/usr/include/c++/4.8.2/bits/c++0x_warning.h:32:2: error: #error This file requires compiler and library support for the ISO C++ 2011 standard. This support is currently experimental, and must be enabled with the -std=c++11 or -std=gnu++11 compiler options.
 #error This file requires compiler and library support for the \
  ^
In file included from ./login_client_sdk/include/login_query_get.h:1:0,
                 from wrapper.cc:4:
./login_client_sdk/include/login_record.pb.h:17:2: error: #error This file was generated by an older version of protoc which is
 #error This file was generated by an older version of protoc which is
  ^
./login_client_sdk/include/login_record.pb.h:18:2: error: #error incompatible with your Protocol Buffer headers. Please
 #error incompatible with your Protocol Buffer headers.  Please
  ^
./login_client_sdk/include/login_record.pb.h:19:2: error: #error regenerate this file with a newer version of protoc.
 #error regenerate this file with a newer version of protoc.
  ^
In file included from /usr/local/include/google/protobuf/stubs/common.h:52:0,
                 from ./login_client_sdk/include/login_record.pb.h:9,
                 from ./login_client_sdk/include/login_query_get.h:1,
                 from wrapper.cc:4:
/usr/local/include/google/protobuf/stubs/mutex.h:58:3: error: ‘mutex’ in namespace ‘std’ does not name a type
   std::mutex mu_;
   ^
/usr/local/include/google/protobuf/stubs/mutex.h: In member function ‘void google::protobuf::internal::WrappedMutex::Lock()’:
/usr/local/include/google/protobuf/stubs/mutex.h:51:17: error: ‘mu_’ was not declared in this scope
   void Lock() { mu_.lock(); }
                 ^
/usr/local/include/google/protobuf/stubs/mutex.h: In member function ‘void google::protobuf::internal::WrappedMutex::Unlock()’:
/usr/local/include/google/protobuf/stubs/mutex.h:52:19: error: ‘mu_’ was not declared in this scope
   void Unlock() { mu_.unlock(); }
                   ^
/usr/local/include/google/protobuf/stubs/mutex.h: At global scope:
/usr/local/include/google/protobuf/stubs/mutex.h:61:7: error: expected nested-name-specifier before ‘Mutex’
 using Mutex = WrappedMutex;
       ^
/usr/local/include/google/protobuf/stubs/mutex.h:61:7: error: ‘Mutex’ has not been declared
/usr/local/include/google/protobuf/stubs/mutex.h:61:13: error: expected ‘;’ before ‘=’ token
 using Mutex = WrappedMutex;
             ^
/usr/local/include/google/protobuf/stubs/mutex.h:61:13: error: expected unqualified-id before ‘=’ token
/usr/local/include/google/protobuf/stubs/mutex.h:66:28: error: expected ‘)’ before ‘*’ token
   explicit MutexLock(Mutex *mu) : mu_(mu) { this->mu_->Lock(); }
                            ^
/usr/local/include/google/protobuf/stubs/mutex.h:69:3: error: ‘Mutex’ does not name a type
   Mutex *const mu_;
   ^
/usr/local/include/google/protobuf/stubs/mutex.h: In destructor ‘google::protobuf::internal::MutexLock::~MutexLock()’:
/usr/local/include/google/protobuf/stubs/mutex.h:67:24: error: ‘class google::protobuf::internal::MutexLock’ has no member named ‘mu_’
   ~MutexLock() { this->mu_->Unlock(); }
                        ^
/usr/local/include/google/protobuf/stubs/mutex.h: At global scope:
/usr/local/include/google/protobuf/stubs/mutex.h:80:33: error: expected ‘)’ before ‘*’ token
   explicit MutexLockMaybe(Mutex *mu) :
                                 ^
In file included from /usr/local/include/google/protobuf/arena.h:48:0,
                 from /usr/local/include/google/protobuf/implicit_weak_message.h:35,
                 from /usr/local/include/google/protobuf/generated_message_util.h:51,
                 from ./login_client_sdk/include/login_record.pb.h:22,
                 from ./login_client_sdk/include/login_query_get.h:1,
                 from wrapper.cc:4:
/usr/include/c++/4.8.2/typeinfo:39:37: error: expected ‘}’ before end of line
 #pragma GCC visibility push(default)
                                     ^
/usr/include/c++/4.8.2/typeinfo:39:37: error: expected unqualified-id before end of line
/usr/include/c++/4.8.2/typeinfo:39:37: error: expected ‘}’ before end of line
/usr/include/c++/4.8.2/typeinfo:39:37: error: expected ‘}’ before end of line
/usr/include/c++/4.8.2/typeinfo:39:37: error: expected ‘}’ before end of line
/usr/include/c++/4.8.2/typeinfo:39:37: error: expected declaration before end of line
```

<font color='red'>仔细看go build报错，这里暴露出了两个问题：</font>

1. C++编译环境问题：`This file requires compiler and library support for the ISO C++ 2011 standard. This support is currently experimental, and must be enabled with the -std=c++11 or -std=gnu++11 compiler options.1`
2. protoc版本不兼容问题：` #error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer headers. Please regenerate this file with a newer version of protoc.` 

按gcc 4.8.2的官方解释，gcc 4.8最主要的一个特性就是全面支持C++11。但是目前看起来并没有实现编译，难道是最开始生成protobuf有问题？

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220731161954.png)

怀疑gcc版本太低，准备尝试换高版本gcc。

google的一些相近案例及其解决方案：

- 参照[github论坛上的回答](https://github.com/ethz-asl/protobuf_catkin/issues/29)，它是通过CMakeCache.txt增加编译参数`-std=c++ 11`；但是在Cgo的编译中，go build并不支持指定C++的编译方式，也不能使用CMakeCache.txt方式。**怎么在编译的时候指定c++ 11的方式，这是一个难题**。

- 另一个回答，OpenCV不能编译过，[是protobuf3.6.1导致的](https://github.com/opencv/opencv/issues/12429)。这个issue的报错和我们也是一样的，让我思考到：**为什么这个和protobuf有关系？**是什么原因导致了不兼容




明确了目前的问题是C++编译连接和protobuf的版本问题，确立了项目<font color='red'>后续实施方案</font>

1. **使用loginclient的源码编译重新生成.a和.so文件**
2. **版本问题要么本地对齐loginclient 静态库依赖（liblogin_query.a）的protobuf版本——protobuf2.4.1**



### 1.1 方案1：直接源码编译Login Client

**方案概述：**对login_record.proto以protobuf3.6.1重新login_record.pb.cc和login_record.pb.h文件，并用C++编译生成相应的.a和.so文件，并在生成过程中指定编译参数`-std=c++ 11`

#### 1.1.1 问题描述

> 刚开始求简单，对login_record.proto以protobuf3.6.1重新login_record.pb.cc和login_record.pb.h文件，并且只对login_record.pb.cc包装成liblogin_query.a。
>
> 但是这种方式会导致liblogin_query.a中类实现不全，在链接时出错。

问题复现：

1. 直接进行`gcc -c *cc`编译，会提示lgoin_query_client.cc，login_record.pb.cc，login_record.pb.h等文件是老版本的，需要用c++11来支持

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220731174116.png)

可以看一下[-std=gnu++11 与 -std=c++11 有什么区别](https://blog.csdn.net/juan202/article/details/79968898)

重新命令行`gcc -std=gnu++11 *.cc`，报错：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220731174532.png)

**但是login_client之前编译出来的login_record.pb.cc的版本是由一个更低的版本protoc生成的。**查看一下我们的protoc --version，是3.6.1。

解决方法：

1. 安装protoc 2.4.1，并且要替换本机的gcc环境
2. 利用login_record.proto，用proto3.6.1重新生成一下login_record.pb.cc和login_record.pb.h

选择方案2：

```shell
[root@VM-236-164-centos ~/login_client]# protoc -I=./login_client --cpp_out=./login_client/include login_record.proto
```

> protoc -I = proto文件路径 --cpp_out = 输出文件路径 proto文件名

```shell
[root@VM-236-164-centos ~/login_client/login_client/include]# tree
.
├── login_query.h
├── login_record.pb.cc
└── login_record.pb.h
```

到include目录下，改用`gcc -std=gnu++11 *.cc`重新编译一下，出现特别undefined reference，

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220731180230.png)

换一种方式，使用`gcc -c -std=c++11 *.cc `，不再报错。

继续推进，生成静态链接库，`ar rcs liblogin_query.a *.o`

重新go build一下qq_login_push。发现和之前一样的问题：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220731193847.png)



还是在C++的编译上出了问题，编译文件`login_record.pb.h`的时候还是出现编译器不支持c++11。[参考enabled -std=c++11](https://github.com/BVLC/caffe/issues/6359)，有一个回答，`use up-to-date protobuf, and add -std=c++11 to CXXFAGS in makefile`

在query_get.go编译头进行指定`// #cgo CPPFLAGS:-I${SRCDIR}/login_client_sdk/include  -std=c++11`：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220731194158.png)

再次go build，发现wrapper.h中有undefined reference：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220731195151.png)

看起来还不能直接加上`-std=c++11`，修改一下：`// #cgo CXXFLAGS:-I${SRCDIR}/login_client_sdk/include  -std=c++11`:

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220731202421.png)

<font color='red'>因此这里有一个知识很重要：</font>

编译参数主要是头文件的检索路径，预定义的宏等参数。理论上来说 C 和 C++ 是完全独立的两个编程语言，它们可以有着自己独立的编译参数。 但是因为 C++ 语言对 C 语言做了深度兼容，甚至可以将 C++ 理解为 C 语言的超集，因此 C 和 C++ 语言之间又会共享很多编译参数。 因此 CGO 提供了 CFLAGS/CPPFLAGS/CXXFLAGS 三种参数，其中 

- CFLAGS 对应 C 语言编译参数 (以 `.c` 后缀名)
- CPPFLAGS 对应 C/C++ 代码编译参数 (*.c,*.cc,*.cpp,*.cxx)
- CXXFLAGS 对应纯 C++ 编译参数 (*.cc,*.cpp,*.cxx)

本次Cgo的调用中，只涉及到C++（对应CXXFLAGS），因此参数一定要设准确（严格遵守规范，是Cgo调用最重要的点）



再次`go build -x query_get.go`。已经可以看到，这个时候的编译已经是在文件中去执行,,<font color='red'>C++11的问题已解决</font>。打印command-line：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220731205213.png)

继续定位报错：

- 发现query_get.go文件中的一个报错，显示无法返回CompiledGoFiles


![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220731201231.png)

根据报错信息找到帮助网页信息（https://golang.org/issue/38990），

看到这句话：

```
What's wrong
When cgo preprocessing fails, go list -json -compiled -e prints an error on stderr and exits with a non-zero status, but it does not populate the Error field of the package. It is possible to detect that something went wrong because CompiledGoFiles isn't populated, but we can't tell why it failed. Two common reasons are a missing C compiler, and missing libraries.
```

**缺乏C编译器，和libs？**

通过提供的指令`go list -json -compiled -e`查找go list运行时错误，当我运行该指令后，看到了更详细的错误信息。

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220731213706.png)

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220731213436.png)

说明一个问题，其实query_get.go已经和wrapper.h关联上了，但是wrapper.cpp中反倒是没有关联上`login_record.h` ?!!

#### 1.1.2 小结，分析原因

> 上面的操作不全，目前的做法只是通过protoc3.6.1把login_record.pb.cc编译成了liblogin_query.a，但是其他的*.cc文件并没有被加入其中，导致最后生成的liblogin_query.a中找不到相关的函数。

- **原因分析：**liblogin_query.a只包含login_query.h声明的执行代码，其它函数实现缺失（如login_recv_client.cc，client_process.cc等）

- **正确的做法：**对login_client整个项目全部重新生成，包括\*.pb.h,\*.pb.cc，\*.cc；最后生成liblogin_query.a

但是这种做法有点问题，比如[login_client的源码](https://git.woa.com/qq_com_dev/sync_login_proj)中可以看到，logn_query.cc中有引入了新的依赖，比如send_buf.h和seq_shm.h（他们在上图的common文件夹下）：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220801105544.png)

，这样就会导致依赖不断扩大，下一步是全部引入后，再编译？然后我们要把全部的*.cc文件都包含进去，这个操作就有点危险（包含不全怎么办？），有大量的Makefile要操作，并且不知道顺序。

综合上述不稳定条件，决定先行放弃这种方式。

### 1.2 方案2：本地对齐login_client依赖的版本库

**方案概述：**login_client源码中已经提供了login_record.proto和liblogin_query.a；目前只差login_record.pb.cc和login_record.pb.h。如果直接用本地protobuf3.6.1生成，会出现上面protoc版本不匹配的原因。

#### 1.2.1 问题描述

login_record.pb.h和login_record.pb.cc都是新版本protoc3.6.1生成的，如果我们直接用这个新版本生成的方案，就是要把login_query.a的生成过程全部包含进去，也就是“源码编译login_client”，但是刚刚也分析了，这种方式依赖的包太多了，不好整。

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220801104003.png)

那干脆用之前已经生成好的login_record.pb.h，反正login_query.h也就只依赖login_record.pb.h，但是login_client的版本依赖库login_record.pb.h必须是protoc2.4.1生成，而本地的protoc版本是3.6.1，不匹配会报错：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220801104415.png)

除了校验版本这个问题，protoc2.4.1和protoc3.6.1生成的代码也不统一：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220801104831.png)

如果直接替换成老的login_record.pb.h就是会报这两个错误：

1. 版本不匹配
2. 一些protobuf的实现类没有定义

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220801111334.png)

可以看到，如果直接用新的login_record.pb.h去链接老的代码库（liblogin_query.a）,会发现两者不匹配。在wrapper.cpp的18行，直接就是找不到LoginRecord的定义：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220801111849.png)

#### 1.2.1 小结，分析原因

要解决这个问题，就只能把[本地protoc版本替换掉](https://blog.csdn.net/wojiushixiangshi/article/details/95043418)！

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220801131848.png)

再次编译login_record.proto文件，生成login_record.pb.cc和login_record.pb.h。

go build一下：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220801132424.png)

这里的意思是找不到google protobuf，没有关联到protobuf？

到此，我们已经将本地的protobuf对齐了login_client的版本了，但是问题还是发生，因为他找到google protobuf的相关定义。因此，**考虑是不是Cgo程序没有办法自己直接去链接相应的静态/动态链接库？**

**①  在Cgo编译链接中增加protobuf的依赖（此时本地已经是2.4.1）：**——经测试，protobuf3.6.1也没问题，只要生成的XXX.pb.cc和XXX.pb.h和protobuf的版本对应即可

```
// #cgo LDFLAGS:-L${SRCDIR}/login_client_sdk/lib/ -llogin_query -lprotobuf
```

再go build一下，还是有两个库找不到，google一下，这是本地的c++库，用于为进程间用共享内存的方法通信提供的两组方法。为什么没有关联到？

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220801132335.png)

请注意一下shm_open的帮助文件的最后几行：

```
NOTES

       These functions are provided in glibc 2.2 and  later.   Programs  using

       these  functions  must  specify  the  -lrt  flag to cc in order to link

       against the required ("realtime") library.

       POSIX leaves the behavior of the combination of  O_RDONLY  and  O_TRUNC

       unspecified.   On  Linux,  this  will successfully truncate an existing

       shared memory object - this may not be so on other Unices.

       The POSIX shared memory object implementation on Linux 2.4 makes use of

a dedicated file system, which is normally mounted under /dev/shm.
```

**② 此时，在Cgo编译链接中增加运行时库（提供了一些额外的函数定义）**：

```
// #cgo LDFLAGS:-L${SRCDIR}/login_client_sdk/lib/ -llogin_query -lprotobuf -lrt
```

再go build一下：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220801132953.png)

对于pb的依赖部分就完全解决了，剩下的就是AvLoginQuery_Get找不到了。检查一下wrapper.h和wrapper.cpp，发现对于函数的定义不一致：

```c++
//wrapper.h
int AvLoginQuery_Get(AvLoginRecord &avRecord);			//参考了login_query.h的定义
//wrapper.cpp
int AvLoginQuery_Get(AvLoginRecord *avRecord){}
```

全部统一为`int AvLoginQuery_Get(AvLoginRecord *avRecord)`后，再go build一下，

```shell
[root@VM-236-164-centos ~/qq_login_push/login_client_go]# go build
# git.woa.com/g_QQRTC/qq_login_push/login_client_go
./query_get.go:30:29: cannot use &avRecord (type *_Ctype_struct_AvLoginRecord) as type *_Ctype_struct___0 in argument to _Cfunc_AvLoginQuery_Get
```

显示`*_Ctype_struct_AvLoginRecord`和传参不一样？

**原因分析：**<font color='red'>Cgo无法为C类型的数据结构按go的形式分配内存</font>

Cgo使用C的结构体需要处理下，虽然可以直接定义`var avRecord *C.struct_AvLoginRecord`，但是这个传参到AvLoginQuery_Get函数中需要取地址。可见并不能直接调用AvLoginQuery_Get，并传递相应的avRecord地址

对login_query.go的调用修改一下：

```c++
var avRecord *C.struct_AvLoginRecord
    
//原始
ret := C.AvLoginQuery_Get(avRecord)
//修改
ret := C.AvLoginQuery_Get((*C.char)(unsafe.Pointer(avRecord)))
```

但是问题是，现在只是定义了一个C.struct_AvLoginRecord类型的指针，怎么给这个指针创建空间呢？在go里面是&XXX，或者new()/make()。修改为`var avRecord =  &C.struct_AvLoginRecord{}`，但是这样就会报错：

```shell
[root@VM-236-164-centos ~/qq_login_push/login_client_go]# go build
# git.woa.com/g_QQRTC/qq_login_push/login_client_go
./query_get.go:28:44: _Ctype_struct_AvLoginRecord is incomplete (or unallocatable); stack allocation disallowed
./query_get.go:29:6: _Ctype_struct_AvLoginRecord is incomplete (or unallocatable); stack allocation disallowed

[root@VM-236-164-centos ~/qq_login_push/login_client_go]# go build
# git.woa.com/g_QQRTC/qq_login_push/login_client_go
./query_get.go:29:17: _Ctype_struct_AvLoginRecord can't be allocated in Go; it is incomplete (or unallocatable)
```

很显然，不能对C的结构体用go的方式分配空间。

**③ 修改调用方式，以go的形式定义数据，并用简单的指针传递，最后用转换成C语言的数据结构作为传参。**

```go
	valueAddress := make([]byte, AVMAXLEN)
	avRecord_Rsp := &login_record.LoginRecord{}
	ret := C.AvLoginQuery_Get((*C.char)(unsafe.Pointer(&valueAddress[0])), C.int(AVMAXLEN))
```

<font color='red' size='5'>解决问题！</font>推送远程，执行蓝盾流水线编译。

**感谢hunting哥的悉心指导！**

### 1.3 总结本次Cgo代码编写和编译过程中一些注意点

> 这次Cgo的调用阻塞了一段时间，究其原因还是不熟悉，很多编译参数和参数需要了解下

#### 1.3.1 C++编译时遇到protobuf版本不一致的问题

go调用到各种C语言的sdk，需要对C的文件进行编译。而项目代码和sdk中都有可能会使用protobuf。

当protobuf版本不一致时，编译就会报错。有两种可能的报错信息

- `This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer headers.  Please update your headers.`（头文件（*.pb.h）高于本地protobuf版本）

- `This file was generated by an older version of protoc which is incompatible with your Protocol Buffer headers.  Please regenerate this file with a newer version of protoc.`（头文件（*.pb.h）低于本地protobuf版本）

问题分析：
项目所依赖的sdk中，自带了业务的\*.pb.h文件，这个文件是和项目所使用的不同版本的protoc所生成的。而在编译时，这些\*.pb.h和\*.pb.cc文件会include项目自带的protobuf的头文件。当这两者的版本出现不一致时，就会报上述的错误。



**要解决这个问题，首先要理解什么是Protobuf环境？**

- Bin文件夹（protoc工具，用于将业务自身的proto文件翻译成代码）
- include文件夹（google protobuf自带的头文件，被前者所依赖）
- lib文件夹（静态包或动态包，项目链接时会用到）。

理解protobuf的作用：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/MBXY-CR-60feac70951dd80e5e50442162929a50.png)

[这幅图就对RPC调用描述的很清楚](https://www.eet-china.com/mp/a63366.html)，protobuf只是提供最开始的XXX.proto的编译。Protobuf 是一种跨语言、跨平台、可扩展的用于序列化数据协议。它把XXX.proto转换成两个实现类，其中服务端程序（EchoService）实现接口中定义的方法，提供服务；客户端（EchoService_Stub）调用接口函数，调用远程的服务。

*方案1就是在第1步就出错了！！*



**[如何解决](https://blog.csdn.net/zhanglehes/article/details/125208351)**：
一种解决方案就是所有的sdk都需要上传\*.proto文件。

然后项目在编译时，强制使用项目自身依赖的protoc工具，生成sdk中的*.pb.h和*.pb.cc文件。这样就能保证项目引用sdk被强制同自身使用的protobuf版本保持一致。

在Cgo中需要指定protobuf：

```
//默认使用protobuf的动态库，其次再用静态库；可能会出现在运行时找不到动态链接库的情况
//#cgo LDFLAGS:-L${SRCDIR}/login_client_sdk/lib/ -llogin_query -lprotobuf
或者直接指定好使用protobuf的静态库
// #cgo LDFLAGS:-L${SRCDIR}/login_client_sdk/lib/ -llogin_query /usr/local/lib/libprotobuf.a
```

#### 1.3.2 Cgo调用时传参不一致的问题

> Cgo的调用要求传入C/C++函数的参数都必须是C的格式， Go的数据类型要保证和C的一致

- C并不了解Go的调用协定或堆栈，所以Go语言调用到C代码时必须首先记录Go函数入口堆栈的所有细节，然后切换到C的堆栈，运行C代码，这部分C代码并不知道它如何被调用，更不知道外部的Go语言运行时环境。
- Go也不知道任何关于C的情况。这就是为什么随着编译器和垃圾收集器在定位无用栈帧和堆方面的发展，Go和C两者之间传递数据的规则变得越来越复杂。
  - 如果在C的运行过程中出现一个错误，Go至少得能做到打印错误堆栈信息，然后退出程序，而不是把核心文件都暴露出来。
  - 管理这种双方互相调用的堆栈、再加上在信号、线程和回调，真的很是不容易的。

具体而言，

1. **C的传参应该尽量保持简洁——传指针或者基本类型：**

```go
	valueAddress := make([]byte, AVMAXLEN)
	avRecord_Rsp := &login_record.LoginRecord{}
	res := C.AvLoginQuery_Get((*C.char)(unsafe.Pointer(&valueAddress[0])), C.int(AVMAXLEN))
```

2. **C的返回值个数受限**——return语句只能返回一个值，如果函数产生了多个运算结果，将无法通过return返回

为此，我们要合理利用C函数的返回值：

```go
	res := C.AvLoginQuery_Get((*C.char)(unsafe.Pointer(&valueAddress[0])), C.int(AVMAXLEN))
    if err := proto.Unmarshal(valueAddress[:res], avRecord_Rsp); err != nil {}
```

比如，我们的实现中，res返回的不再是0/-1这种标志函数是否执行成功的int值，而是数组长度。

另一种方式，更加健康：

[使用全局变量或指针实现函数多个结果返回。](https://www.57bz.cn/news/nmppopmtttloqumoslt.html)

##### PS：这里还涉及到函数生命周期的问题

我们使用go代码调用C函数的时候，C函数的生命周期与局部函数是一样的。一旦函数调用结束返回主调函数，在函数中定义的所有形参和局部变量将不复存在，相应的存储单元由系统收回。

因此，如果go代码中需要使用C中的数据，最好拷贝到自己的内存空间；

当然，延长C函数的生命周期也不失为一种方案，比如定义全局变量，或者定义实现类（类中声明函数和变量，然后让go代码一直持有C的实现类）——但是这种方式的成本比较高，有些数据相当于一直没有被释放

比如这种定义结构体的方式，让Decoder() 和MyDecoder生命周期保持一致：

```c++
struct MyDecoder: Decoder {
    MyDecoder(): Decoder() {}
    ~MyDecoder() {}
};

MyDecoder* CreateApi(int duration, int *iErrCode) {
  MyDecoder *api = new MyDecoder();
  if (!api->Init(duration)) {
    return NULL;
  }
  return api;
}

int DecodeAudioData(MyDecoder *decoder, const char *encode_data, int encode_len, int seq){
    return decoder->Decode(encode_data, encode_len, seq);
}
```



## 2、 蓝盾流水线编译的2个问题和1个改进

## 2.1 tlinux_ci:latest基础编译镜像缺少protobuf的问题

1. 构建基础编译镜像，主动打包好protobuf；推送到远程仓库；[流水线地址](https://devops.woa.com/console/pipeline/qqrtc/p-604d42d33ce84f6fa658c5c9c2fb27c7/detail/b-b7c55b7668bf4fc997ee98e3af9ed1c9)

```dockerfile
cat > Dockerfile << EOF

FROM mirrors.tencent.com/ci/tlinux_ci:latest

USER root

RUN wget https://github.com/protocolbuffers/protobuf/releases/download/v3.6.1/protobuf-all-3.6.1.tar.gz \
	&& tar -xzvf protobuf-all-3.6.1.tar.gz \
	&& cd protobuf-3.6.1 \
	&& ./configure  \
	&& make \
	&& make check \
	&& make install 
EOF
```

并以此为基础镜像编译qq_login_push二进制文件



## 2.2 运行时镜像中缺少protobuf.so文件

**出现的问题：**在stke的运行时镜像（）上没有安装protobuf，没有protobuf.a和protobuf.so等相关文件，

```shell
[root@qqavloginpush-clrc1oyd0s00-0 /usr/local/services/qq_av_login_push/bin]# cd /usr/local/lib
[root@qqavloginpush-clrc1oyd0s00-0 /usr/local/lib]# ll
total 0
```

在运行qq_login_push的时候，会报错`缺少protobuf.so文件`！

**问题原因：**

由于Cgo编译的时候没有指定连接的protobuf库是静态库还是动态库，

```
// #cgo LDFLAGS:-L${SRCDIR}/login_client_sdk/lib/ -llogin_query -lprotobuf -lrt
```

默认会关联动态库，导致基础编译镜像go build 的时候会绕过这里。到运行qq_login_push的时候，运行时镜像才会去关联，此时报错！

**两种解决方法：**

1. 在C++的编译链接的时候指定从protobuf.a文件中获取

```go
// #cgo LDFLAGS:-L${SRCDIR}/login_client_sdk/lib/ -llogin_query /usr/local/lib/libprotobuf.a -lrt
```

因为是Cgo代码，在go build的时候就会直接连接到静态链接库protobuf.a，并且执行完毕

2. 向运行时镜像中打包过去protobuf.so文件

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220802162124.png)

两种方案，第一种会让服务和编译镜像耦合，第二种会让服务和运行镜像耦合，目前没有好的解决方法，采用的是方法1。

**为什么会选择第二种指定静态库的方式？**

- 其实还是考虑到依赖的问题。众所周知，**go的非常大的优势在于编译后是无依赖的，**然而，如果go里面掺杂了c的代码（多半是要借助现有的c的类库），编译后的程序就有依赖了。
- c的程序也可以运行时无依赖的，就是所谓的**静态编译**，这个需要依赖库提供静态库文件；于是，cgo也能静态编译，使得编译后的程序无依赖。





## 2.3改进：实现编译和运行镜像分离和stke自动部署

1. 在基础镜像上编译proto，并编译生成qq_login_push二进制文件

```
protoc -I=/data/landun/workspace/login_client_go/ --cpp_out=./login_client_go/ login_record.proto
# echo "heloo?"
# #protoc --version
# echo "heloo?"
source /etc/profile
go clean
go build
```

推送镜像；

3. 配置TKEx-CSIG部署

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220807210752.png)



蓝盾流水线地址：https://devops.woa.com/console/pipeline/qqrtc/p-324d5ccd6c534798848b4d755398bb7a/detail/b-e924c7f3454742cba70efa4caaac032e









