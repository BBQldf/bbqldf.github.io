---
layout:     post
title:     SpringBoot基础03
subtitle:   SpringBoot-实战分析、新框架的整合
date:       2022-01-09
author:     ldf
header-img: img/post-bg-springboot03.png
catalog: true
tags:
    - java基础
    - SpringBoot
    - code
---

# 一、实战1：员工管理系统

> 项目来源：https://blog.csdn.net/qq_45173404/article/details/108934414
>
> **资料下载**
>
> **内含源码 + 笔记 + web素材**
>
> 链接：https://pan.baidu.com/s/1ITFMd_myJBYI3zv1N9w_Aw
> 提取码：z7x8

## 1、准备工作

### 1). 构建好一个SpringBoot项目

- 项目名为SpringBoot-04-EmployeeDepartment
- 选择配件时勾选SpringWeb和Thymeleaf
- 删除掉多余的mvn组件，只需要主框架（src下的main、test）
- **修改一下文件编码**（这个很重要，也经常搞忘记！）

![以login为例子](C:\Users\705lab\AppData\Roaming\Typora\typora-user-images\image-20220110164840075.png)

### 2). 下载上面的源码，导入里面的静态资源

- 首先创建不存在的静态资源目录public和resources
- 将html静态资源放置templates目录下
- 将asserts目录下的css、img、js等静态资源放置static目录下

![](C:\Users\705lab\AppData\Roaming\Typora\typora-user-images\image-20220110163435441.png)

### 3). 编写Dao层、Pojo层、Controller层

> 由下至上的思想，完成编写

1. **Pojo层**

> 

- 导入lombok

```pom
<dependency>
 <groupId>org.projectlombok</groupId>
 <artifactId>lombok</artifactId>
</dependency>
```

- Department实体类

```java
//部门表
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Department {
    private Integer id;
    private String departmentName;

}
```

- Employee实体类

```java
//员工表
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Employee {
    private Integer id;    //jdk5.0之后加入了自动装箱和拆箱，所以最好使用包装类
    private String lastName;
    private String email;
    private Integer gender;//0:女 1:男
    private Department department;
    private Date date;
}
```



2. **Dao层**

在主程序同级目录下新建dao包，然后分别编写DepartmentDao和EmployeeDao，并在其中模拟数据库的数据

- DepartmentDao：

```java
//注册到IOC容器中
@Repository   //dao层专用注解
public class DepartmentDao {
    //模拟数据库中的数据
    private static Map<Integer, Department> departments = null;

    static {
        departments = new HashMap<>();//创建一个部门表
        departments.put(1, new Department(1, "技术部"));
        departments.put(2, new Department(2, "市场部"));
        departments.put(3, new Department(3, "调研部"));
        departments.put(4, new Department(4, "后勤部"));
        departments.put(5, new Department(5, "运营部"));
    }

    //获得部门的所有信息
    public Collection<Department> departments() {
        return departments.values();
    }

    //通过id得到部门
    public Department getDepartmentById(int id) {
        return departments.get(id);
    }
}
```

- EmployeeDao

```java
//注册到IOC容器中
@Repository
public class EmployeeDao {
    //模拟数据库中员工表的数据
    static private Map<Integer, Employee> employees;

    @Autowired//自动
    private DepartmentDao departmentDao;

    static {
        employees = new HashMap<>();//创建一个员工表
        employees.put(1, new Employee(1, "zsr", "1234@qq.com", 1, new Department(1, "技术部"), new Date()));
        employees.put(2, new Employee(2, "lyr", "1345@qq.com", 1, new Department(2, "市场部"), new Date()));
        employees.put(3, new Employee(3, "gcc", "5665@qq.com", 0, new Department(3, "调研部"), new Date()));
        employees.put(4, new Employee(4, "zyx", "7688@qq.com", 1, new Department(4, "后勤部"), new Date()));
        employees.put(5, new Employee(5, "zch", "8089@qq.com", 1, new Department(5, "运营部"), new Date()));
    }

    //主键自增
    private static Integer initialID = 6;

    //增加一个员工
    public void addEmployee(Employee employee) {
        if (employee.getId() == null)
            employee.setId(initialID++);
        employee.setDepartment(departmentDao.getDepartmentById(employee.getDepartment().getId()));
        employees.put(employee.getId(), employee);
    }

    //查询全部员工信息
    public Collection<Employee> getAllEmployees() {
        return employees.values();
    }

    //通过id查询员工
    public Employee getEmployeeByID(Integer id) {
        return employees.get(id);
    }

    //通过id删除员工
    public void deleteEmployeeByID(Integer id) {
        employees.remove(id);
    }
}
```

3. **Controller层**（设置功能：访问http://localhost:8080/；http://localhost:8080/index.html都是首页）

```
@Controller
public class IndexController {

    @RequestMapping({"/","/index.html"})
    public String index(){
        return "index";
    }
}
```

- 测试效果（<font color="red">css样式需要在index.html修改为Thymeleaf模板引擎</font>）：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220110200453.png)

但是这种MVC的风格并不是SpringBoot的主流，对于页面的配置，我们习惯于用一个新的Config文件处理！

## 2、首页实现

1. 创建一个MyMvcConfig控制类（为了区分和上面的Controller效果，我在addViewController用的路径是"/index22.html"）

```java
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        //这两个浏览器路径映射到templete/index.html文件
        registry.addViewController("/").setViewName("index");
        registry.addViewController("/index22.html").setViewName("index");
    }
}

```

- **测试效果：**

![image-20220110202243203](C:\Users\705lab\AppData\Roaming\Typora\typora-user-images\image-20220110202243203.png)

<font size='5' color='red'>注意点：</font>

1. 所有html都需要引入Thymeleaf命名空间`xmlns:th="http://www.thymeleaf.org"`
2. 修改所有页面静态资源的引入，使用@{...} 链接表达式`<link th:href="@{/css/signin.css}" rel="stylesheet">`
   - 第一个/代表项目的classpath，可以随着项目名设置而变化
3. 关闭模板引擎的缓存`spring.thymeleaf.cache=false`

## 3、国际化（中英文切换）i18n

**命名方式**是下划线的组合：文件名`xxx_语言_国家.properties`；

### 1). 新建三个配置文件,用来配置语言:

- login. properties :无语言配置时候生效
- login_en_US.properties : 英文生效
- login_zh_CN.properties :中文生效

IDEA会帮我们识别这是个国际化配置包，自动绑定（resource bundle）在一起转换成如下的模式

![resource bundle](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220110204122.png)



### 2). 编写配置属性

- login.properties

```properties
login.btn=登录
login.password=密码
login.remember=记住我
login.tip=请登录
login.username=用户名
```

- login_en_US.properties

```properties
login.btn=Sign in
login.password=Password
login.remember=Remember me 
login.tip=Please sign in
login.username=Username
```

- login_zh_CN.properties

```properties
login.btn=登录
login.password=密码
login.remember=记住密码
login.tip=请登录
login.username=用户名
```

解决一个问题，新版idea开发[国际化i18n时找不到Resource Bundle](https://blog.csdn.net/m0_52241823/article/details/121850065) 可视化界面问题

![安装插件后](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220110205210.png)

### 3). 国际化配置生效

> 国际化主要是通过ResourceBundleMessageSource这个类来实现的，Spring Boot通过MessageSourceAutoConfiguration为我们自动配置好了管理国际化资源文件的组件

- 如果你不在springboot配置文件中指定以.分隔开的国际化资源文件名称的话
- 它默认会去类路径下找messages.properties作为国际化资源文件
- 我们自定义了国际化资源文件，因此我们需要在SpringBoot配置文件application.properties中加入以下配置指定我们配置文件的名称

```properties
#其中i18n是存放资源的文件夹名，login是资源文件的基本名称。
spring.messages.basename=i18n.login
```

### 4). 在首页中关联配置

- 利用#{...} 消息表达式，去首页index.html获取国际化的值

```
			<a class="btn btn-sm" th:href="@{/index.html(l='zh_CN')}">中文</a>
			<a class="btn btn-sm" th:href="@{/index.html(l='en_US')}">English</a>
```

首先在这两个标签上加上跳转链接并带上相应的参数

- 自定义地区解析器（LocaleResolver）组件

- 源码分析：
  - 位置：WebMvcAutoConfiguration——>localeResolver()
  - 默认地区解析器的是AcceptHeaderLocaleResolver对象。它继承了LocaleResolver接口，实现了地区解析

因此我们想要实现上述自定义的国际化资源生效，只需要**编写一个自己的地区解析器，继承LocaleResolver接口，重写其方法即可！！**

### 5). 实现自定义的地区解析器

1. 在config目录下创建MyLocaleResolver类

```java
public class MyLocaleResolver implements LocaleResolver {
    //解析请求
    @Override
    public Locale resolveLocale(HttpServletRequest request) {
        //获取请求中的国际化参数
        String language = request.getParameter("l");
        //默认的地区
        Locale locale = Locale.getDefault();
        //如果请求的链接参数不为空,携带了国际化参数
        if (!StringUtils.isEmpty(language)) {
            String[] split = language.split("_");//zh_CN(语言_地区)
            locale = new Locale(split[0], split[1]);
        }
        return locale;
    }

    @Override
    public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {

    }
}
```

## 6). 在自己的MvcConofig配置类下添加bean，使组件生效

```
    //自定义国际化组件
    @Bean
    public LocaleResolver localeResolver(){
        return new MyLocaleResolver();
    }
```

- 测试效果：

![测试成功](C:\Users\705lab\AppData\Roaming\Typora\typora-user-images\image-20220110211232180.png)

## 4、登录功能实现

> 实现要求：登录，也就是当我们点击登录按钮的时候，会进入一个页面，这里进入dashboard页面

### 1). 修改inde.html，增加传递参数

```html
<input type="text" name="username" class="form-control" th:placeholder="#{login.username}" required="" autofocus="">
<input type="password" name = "password" class="form-control" th:placeholder="#{login.password}" required="">
```

给名称和密码输入框添加name属性为了后面的传参

### 2). 编写对应的controller

> 新建/controller/loginController类，处理登录请求

实现效果：

1. 登陆成功，跳到dashboard.html界面
2. 登陆失败，回到index.html，并且弹出提示！

```java
@Controller
public class LoginController {
    @RequestMapping("/user/login")
    public String login(@RequestParam("username") String username, @RequestParam("password") String password, Model model) {
        //如果用户名和密码正确
        if ("admin".equals(username) && "123456".equals(password))
            return "dashboard";//跳转到dashboard页面
            //如果用户名或者密码不正确
        else {
            model.addAttribute("msg", "用户名或者密码错误");//显示错误信息
            return "index";//跳转到首页
        }
    }
}
```

因此，在index.html中添加加一个标签用来显示controller返回的错误信息

```html
<p style="color: red" th:text = "${msg}" th:if="${not #strings.isEmpty(msg)}" ></p>
```

`th:if="${not #strings.isEmpty(msg)}`保证了如果msg为空，就不显示

- **测试效果：**

![输入正确&输入错误](C:\Users\705lab\AppData\Roaming\Typora\typora-user-images\image-20220110213343651.png)

有一个问题，这个url暴露了个人信息。回顾SpringMVC，可以用映射解决这个问题。

### 3). 在自定义的配置类MyMvcConfig中增加映射

>  用另外一个url桥接一下。相当于加了一个伪装

1. 在LoginController中设置重定向（登录成功和登陆失败都设置一下）

```java
@Controller
public class LoginController {
    @RequestMapping("/user/login")
    public String login(@RequestParam("username") String username, @RequestParam("password") String password, Model model) {
        //如果用户名和密码正确
        if ("admin".equals(username) && "123456".equals(password)) {
            return "redirect:/main.html";//重定向到main.html页面,也就是跳转到dashboard页面
        }
            //如果用户名或者密码不正确
        else {
            model.addAttribute("msg", "用户名或者密码错误");//显示错误信息
            return "redirect:/index222.html";//跳转到首页
        }
    }
}
```

2. 在MyMvcConfig中增加映射

```java
     registry.addViewController("/main.html").setViewName("dashboard");
```

测试效果：

![登录失败&登陆成功](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220110214416.png)

但是这个还不够，因为有个问题，就是dashboard.html目前是所有人都可以从URL中访问到：http://localhost:8080/dashboard.html；解决这个问题就是SpringMVC中的拦截器！

## 5、拦截器-Interceptor

> 用户登录成功后，后台会得到用户信息；如果没有登录，则不会有任何的用户信息，并且返回

1. 在LoginController中当用户登录成功后，存入用户信息到session中

```java
        //如果用户名和密码正确
        if ("admin".equals(username) && "123456".equals(password)) {
            session.setAttribute("LoginUser", username);
            return "redirect:/main.html";//重定向到main.html页面,也就是跳转到dashboard页面
        }
```

2. 在config目录下，新建一个登录拦截器类LoginHandlerInterceptor

```java
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        Object loginUser = request.getSession().getAttribute("LoginUser");
        if (loginUser == null){
            request.setAttribute("msg", "权限不够,请先登录");
            //转发，跳转回index.html页面
            request.getRequestDispatcher("/index.html").forward(request, response);
            //不放行规则
            return false;
        }else {
            return true;    //  放行
        }
    }
```

3. 注册拦截器到bean中；在MyMvcConfig配置类中，重写关于拦截器的方法，添加我们自定义的拦截器（已有的方法要用@Override）

```java
   @Override
   public void addInterceptors(InterceptorRegistry registry){
        registry.addInterceptor(new MyInterceptor()).addPathPatterns("/**").excludePathPatterns("/index.html","/","/user/login/**","/css/**","/js/**","/img/**");
   }
```

- 测试效果：

![左上：登录错误！&&右上：登陆成功&&下：登录失败，并直接访问main.html](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220111151545.png)

## 6、员工信息处理CRUD

> 修改一下dashboard，里面有个Customers；把这个作为员工管理操作的入口，点进去之后进行增删改查的操作！
>
> 因此，**在templates目录下新建一个包emp，用来放所有关于员工信息操作的页面**

1. 修改dashboard.html（svg标签是图标）

```
						<a class="nav-link" th:href="@{/employees}">
							<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-users">
								<path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
								<circle cx="9" cy="7" r="4"></circle>
								<path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
								<path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
							</svg>
							Customers
						</a>
```

Customers部分标签添加href属性，实现点击该标签请求/employers路径跳转到list.html展示所有的员工信息

### 6.1 员工信息展示——查（最easy）

1. 在controller包下，新建一个EmployeeController类；处理/employers请求

```java
@Controller
public class EmployeeController {
    @Autowired
    private EmployeeDao employeeDao;

    @RequestMapping("/employees")
    public String listAll(Model model){
        System.out.println("employees访问");
        Collection<Employee> allEmployees = employeeDao.getAllEmployees();
        model.addAttribute("emps",allEmployees);
        return "emp/list";
    }
}
```

跳转到/emp/list.html文件中，并向其中传递allEmployees的值！

2. 修改list.html文件，引入emps

```html
								<tr>
									<th>id</th>
									<th>lastName</th>
									<th>email</th>
									<th>gender</th>
									<th>department</th>
									<th>birth</th>
								</tr>
							</thead>
							<tbody>
								<tr th:each="emp:${emps}">
									<td th:text="${emp.getId()}"></td>
									<td th:text="${emp.getLastName()}"></td>
									<td th:text="${emp.getEmail()}"></td>
									<td th:text="${emp.getGender()==0?'女':'男'}"></td>
									<td th:text="${emp.department.getDepartmentName()}"></td>
									<td th:text="${#dates.format(emp.getDate(),'yyyy-MM-dd HH:mm:ss')}"></td>
```

测试成功！

**PS：有一些问题：**

1. list.html和dashboard.html页面的侧边栏和顶部栏是相同的，可以抽取出来，实现代码复用

**原理：**运用Thymeleaf模板引擎的*[Fragments](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#fragments)*组件

- 修改dashboard.html；增加` th:fragment`

```html
<!--顶部栏-->
<nav class="navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0" th:fragment="topbar">
<!--侧边栏：list.html和dashboard.html页面的侧边栏和顶部栏是相同的，可以抽取出来-->
		<nav class="col-md-2 d-none d-md-block bg-light sidebar" th:fragment="sidebar">
```

- 修改list.html；增加`th:replace`（或者`th:insert`会自动嵌套一层div）规则

```html
		<!--顶部导航栏-->
		<div th:insert="~{dashboard::topbar}"></div>
        <!--侧边栏-->
		<div th:insert="~{dashboard::sidebar}"></div>
```

- 这个还是不太解耦——我们可以用一个公共的区域来放置这些复用代码——新建一个common目录，放置刚刚的顶部栏、侧边栏

- **修改dashboard.html和list.html；**增加`th:replace`（或者`th:insert`会自动嵌套一层div）规则

```html
		<!--顶部导航栏-->
		<div th:replace="~{commons/commons::topbar}"></div>
						<!--侧边栏-->
				<div th:replace="~{commons/commons::sidebar}"></div>
```

2. 点击了Customers后，它应该处于高亮状态，但是这里点击后还是普通的样子，高亮还是在Dashboard上

- 原理：`nav-link-active`表示高亮；在commons中增加判断

```html
 <!--判断，如果是main首页，就高亮；并且点击后，跳转到index.html-->
                    <a th:class="${active=='main.html'?'nav-link active':'nav-link'}" th:href="@{/index.html}">
                    <!--判断，如果是list员工界面，就高亮；点击后跳转到/employees的Controller处理-->
                <a th:class="${active=='list.html'?'nav-link active':'nav-link'}" th:href="@{/employees}">
```

- 在dashboard中增加引用，表示这个是main.html

```html
		<!--侧边栏-->
		<!--传递参数给组件-->
		<div th:replace="~{commons/commons::sidebar(active='main.html')}"></div>
```

- 在list中增加引用，表示这个是list.html

```html
				<!--侧边栏-->
				<div th:replace="~{commons/commons::sidebar(active='list.html')}"></div>
```

![高亮和Controller控制](C:\Users\705lab\AppData\Roaming\Typora\typora-user-images\image-20220111172405508.png)

### 6.2 员工信息增加——增

1. list.html中增加添加按钮（默认是get请求）

```html
<h2><a class="btn btn-sm btn-success" th:href="@{/empAdd}">添加员工</a></h2>
```

2. Controller中添加一个新的@GetMapping

```java
    @GetMapping("/empAdd")
    public String add(Model model) {
        //查出所有的部门信息,添加到departments中,用于前端接收
        Collection<Department> departments = departmentDao.getDepartments();
        model.addAttribute("departments", departments);
        return "emp/add";//返回到添加员工页面
    }
```

到此，就可以跳到add.html界面了

3. 新建add.html，前后都和list.html保持一致，核心form表单修改一下（post请求）——注意：表单中的name名字要和EmployeeDao中完全一致

```html
					<form th:action="@{/empAdd}" method="post" >
						<div class="form-group" ><label>LastName</label>
							<input class="form-control" placeholder="kuangshen" type="text" name="lastName" required="">
						</div>
						<div class="form-group" ><label>Email</label>
							<input class="form-control" placeholder="24736743@qq.com" type="email" name="email" required>
						</div>
						<div class="form-group" ><label>Gender</label><br/>
							<div class="form-check form-check-inline">
								<input class="form-check-input" name="gender" type="radio" value="1">
								<label class="form-check-label">男</label>
							</div>
							<div class="form-check form-check-inline">
								<input class="form-check-input" name="gender" type="radio" value="0" checked>
								<label class="form-check-label">女</label>
							</div>
						</div>
						<div class="form-group" ><label>department</label>
							<select class="form-control" name="department.id">
								<!--查部门的信息-->
								<option th:each="dept:${departments}" th:text="${dept.getDepartmentName()}" th:value="${dept.getId()}"></option>
							</select>
						</div>
						<div class="form-group" >
							<label >Birth</label>
							<input class="form-control" placeholder="输入格式yy/mm/dd;或者yy/mm/dd HH:mm:ss" type="text" name="date" required="">
						</div>
						<button class="btn btn-primary" type="submit">添加</button>
					</form>
```

4. 同样在`EmployeeController`中添加一个方法`empAdd`用来处理点击`添加按钮`的操作

```java
    @PostMapping("/empAdd")
    public String empAdd(Employee employee) {
        System.out.println("employees添加成功");
        employeeDao.addEmployee(employee);
        //必须要重定向到查询所有的员工界面，直接返回，界面是空的，因为没有msg被传进去
        return "redirect:employees";
    }
```

测试效果：

![成功插入；但是有空值，把上面的form表单中每一项最后加入语句required=""](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220111193011.png)

- 也可以在application.properties添加修改日期格式（但是目前已经不支持了）

```properties
#时间日期格式化
#spring.mvc.date-format=yyyy-MM-dd
```



### 6.3 员工信息更新——改

> 当我们点击编辑标签时，应该跳转到编辑页面edit.html

1. 修改list.html页面，添加修改信息(RestFul风格)

```html
<a class="btn btn-sm btn-primary" th:href="@{/edit/{id}(id=${emp.getId()})}">编辑</a>
```

2. 在EmployeeController中添加一个方法edit用来处理list页面点击编辑按钮的操作，返回给update.html页面

```
    //restful风格接收参数
    @RequestMapping("/edit/{id}")
    public String edit(@PathVariable("id") int id, Model model) {
        //查询指定id的员工
        Employee employeeByID = employeeDao.getEmployeeByID(id);
        //添加到empByID中,用于前端接收
        model.addAttribute("empByID", employeeByID);
        //查出所有的部门信息
        Collection<Department> departments = departmentDao.getDepartments();
        //添加到departments中,用于前端接收(下拉菜单需要)
        model.addAttribute("departments", departments);
        return "/emp/update";//返回到编辑员工页面
    }
```

3. 创建update.html文件，接受model传过来的参数(提交post请求，转到/edit的Controller中执行)

```html
					<form th:action="@{/edit}" method="post" >
						<input type="hidden" name="id" th:value="${empByID.getId()}">
						<div class="form-group" ><label>LastName</label>
							<input th:value="${empByID.getLastName()}" class="form-control" placeholder="kuangshen" type="text" name="lastName">
						</div>
						<div class="form-group" ><label>Email</label>
							<input th:value="${empByID.getEmail()}" class="form-control" placeholder="24736743@qq.com" type="email" name="email">
						</div>
						<div class="form-group"><label>Gender</label><br/>
							<div class="form-check form-check-inline">
								<input th:checked="${empByID.getGender()==1}" class="form-check-input" name="gender" type="radio" value="1">
								<label class="form-check-label">男</label>
							</div>
							<div class="form-check form-check-inline">
								<input th:checked="${empByID.getGender()==0}" class="form-check-input" name="gender" type="radio" value="0">
								<label class="form-check-label">女</label>
							</div>
						</div>
						<div class="form-group" ><label>department</label>
							<select class="form-control" name="department.id">
								<option th:selected="${dept.id==empByID.getDepartment().getId()}" th:each="dept:${departments}" th:text="${dept.getDepartmentName()}" th:value="${dept.getId()}"></option>
							</select>
						</div>
						<div class="form-group" >
							<label >Birth</label>
							<input th:value="${#dates.format(empByID.getDate(),'yyyy/MM/dd HH:mm:ss')}" class="form-control" placeholder="yyyy/MM/dd HH:mm:ss" type="text" name="date">
						</div>
						<button class="btn btn-primary" type="submit">修改</button>
					</form>
```

注意点：

- input的name属性要和dao层保持一致
- form中要用Thymeleaf模板引擎
- 性别gender需要处理，check一下参数值:`th:checked="${empByID.getGender()==1}`,判断是不是男性
- 部门department需要处理，根据model传过来的`departments`判断`th:selected="${department.getId()==empByID.department.getId()}"`，部门要和employee的id对应（相等）；并且显示的值为`th:text="${department.getDepartmentName()}"`，传递给表单的值为`th:value="${department.getId()}"`，两个值的用法不一样。
- 日期的格式要调一下`th:value="${#dates.format(emp.birth,'yyyy/MM/dd HH:mm:ss')}"`，默认的传递（`yyyy-MM-dd HH:mm:ss`）无法被后端识别。

4. EmployeeController中添加empEdit方法

```java
    @PostMapping("/edit")
    public String empEdit(Employee employee) {
        employeeDao.addEmployee(employee);//添加一个员工
        return "redirect:/employees";//添加完成重定向到/emps,刷新列表
    }
```

5. 上述的表单中没有传入employee的id到empEdit方法中，所以表单更新一下（隐藏属性）：

```html
<input type="hidden" name="id" th:value="${empByID.getId()}">
```

- 测试结果：

![对id为4的用户进行修改](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220112101401.png)

### 6.4 员工信息删除——删

> 当我们点击`删除`标签时，应该发起一个请求，删除指定的用户，然后重新返回到`list`页面显示员工数据

1. list.html文件中增加删除按钮（采用了和edit按钮不同的传参操作，但是都是RestFul风格）

```
<a class="btn btn-sm btn-danger"  th:href="@{/delEmp/}+${emp.getId()}">删除</a>
```

2. 编写对应的controller，处理点击`删除`按钮的请求，删除指定员工

```java
    @GetMapping("/delEmp/{id}")
    public String delete(@PathVariable("id") Integer id) {
        employeeDao.deleteEmployeeByID(id);//删除一个员工
        return "redirect:/employees";//添加完成重定向到/employees,刷新列表
    }
```

- 测试效果：

![删除成功](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220112102059.png)

## 7、404页面实现&注销

### 7.1 404页面

> springboot框架已经自动完成了错误界面的配置，同时也有响应码code=500等

只需要在`templates`目录下新建一个`error`包，然后将`404.html`（内容可以自己设计）放入其中，404报错后SpringBoot就会自动找到这个页面

- 测试效果：

![要先登录，否则这些地址会被前面的拦截器拦截](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220114200244.png)

### 7.2注销操作

1. 在commons的顶部导航栏部分添加注销按钮

```html
<a class="nav-link" th:href="@{/user/logout}">注销</a>
```

编写对应的controller，处理点击*注销*标签的请求

```java
    @RequestMapping("/user/logout")
    public String logout(HttpSession session) {
        //清除session
        session.invalidate();
        //重定向到首页
        return "redirect:/index.html";
    }
```

## 8、整合SpringData-JDBC

> 对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，**Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。**
>
> Spring Data 也是 Spring 中与 Spring Boot、Spring Cloud 等齐名的知名项目。
>
> 官网：https://spring.io/projects/spring-data

### 8.1 预备工作

在新建项目时，可以勾选我们需要的依赖，就像上面的web-starter一样。（这次需要勾选web、jdbc、mysql driver）

1. 本质上，就是在pom.xml中添加启动器starter

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
```

2. 编写yaml配置文件连接数据库

```yaml
spring:
  datasource:
    username: root
    password: 123456
    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
```

然后就可以直接使用了，因为SpringBoot已经自动配置了。

3. 编写一个测试类（test目录）

```java
@SpringBootTest
class SpringBoot05JdbcApplicationTests {

    @Autowired
    DataSource dataSource;
    @Test
    void contextLoads() throws SQLException {
        //看一下默认数据源
        System.out.println(dataSource.getClass());

        //获得连接
        Connection connection = dataSource.getConnection();
        System.out.println(connection);
        //关闭连接
        connection.close();

    }

}
```

测试效果：

![默认配置的数据源为 : class com.zaxxer.hikari.HikariDataSource；连接数据库成功！](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220114202840.png)

### 8.2 JDBCTemplate实现

> 使用原生的 JDBC 语句来操作数据库CRUD
>
> 即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即**JdbcTemplate**。

- 位置：jdbcTemplateAutoConfiguration——>jdbcTemplate
- JdbcTemplate主要提供以下几类方法：
  - execute方法：可以用于执行任何SQL语句（用的最多也最简单）；
  - update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；
  - query方法及queryForXXX方法：用于执行查询相关语句；
  - call方法：用于执行存储过程、函数相关语句。

- 编写一个Controller，注入 jdbcTemplate，编写测试方法进行访问测试（不一一讲解了，一次性写完，基本原理都是一样的web+jdbc）

```java

//直接返回字符串；不需要@ResponseBody辅助
@RestController
//@RequestMapping("/jdbc")
public class JdbcController {


    /**
     * Spring Boot 默认提供了数据源，默认提供了 org.springframework.jdbc.core.JdbcTemplate
     * JdbcTemplate 中会自己注入数据源，用于简化 JDBC操作
     * 还能避免一些常见的错误,使用起来也不用再自己来关闭数据库连接
     */
    @Autowired
    JdbcTemplate jdbcTemplate;

    //查询数据库的所有信息
    //现在有一个问题，没有实体类，数据库的东西怎么获取？——Map方法
    @GetMapping("/userList")
    public List<Map<String,Object>> userList(){
        System.out.println("查询所有信息！");
        String sql = "select * from mybatis.user";
        //String sql = "select * from user";  //两种方法都可以，可以不写数据库名字
        List<Map<String, Object>> maps = jdbcTemplate.queryForList(sql);
        return maps;
    }


    //新增一个用户
    @GetMapping("/add")
    public String addUser(){
        System.out.println("增加一个用户！");
        //插入语句，注意时间问题
        String sql = "insert into user(id, name,pwd)" +
                " values (555,'newHere','1234564123')";
        jdbcTemplate.update(sql);
        //查询
        return "addOk";
    }


    //修改用户信息
    @GetMapping("/update/{id}")
    public String updateUser(@PathVariable("id") int id){
        System.out.println("更新一个用户！");
        //插入语句
        String sql = "update user set name=?,pwd=? where id="+id;
        //数据
        Object[] objects = new Object[2];
        objects[0] = "gogonew0114";
        objects[1] = "20220114";
        //传递两个参数
        jdbcTemplate.update(sql,objects);
        //查询
        return "updateOk";
    }


    //删除用户
    @GetMapping("/delete/{id}")
    public String delUser(@PathVariable("id") int id){
        System.out.println("删除一个用户！");
        //插入语句
        String sql = "delete from user where id=?";
        jdbcTemplate.update(sql,id);
        //查询
        return "deleteOk";
    }


}
```

测试效果：

![CRUD](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220114211733.png)



# 二、SpringBoot集成Druid

> Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。
>
> Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。
>
> Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 **Hikari （速度快）与 Driud （监控功能）**都是当前 Java Web 上最优秀的数据源。
>
> Github地址：https://github.com/alibaba/druid/

## 1、配置数据源

1. 添加Druid数据源依赖

```xml
<!-- https://mvnrepository.com/artifact/com.alibaba/druid -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.2.8</version>
</dependency>
```

2. 切换数据源（默认使用 com.zaxxer.hikari.HikariDataSource 数据源，但可以 通过 spring.datasource.type 指定数据源。）

```yaml
spring:
  datasource:
    username: root
    password: 123456
    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
```

3. 进行一些细化配置（比较特别的就是它的监控统计拦截的功能）

```yaml
   #Spring Boot 默认是不注入这些属性值的，需要自己绑定
    #druid 数据源专有配置
    initialSize: 5
    minIdle: 5
    maxActive: 20
    maxWait: 60000
    timeBetweenEvictionRunsMillis: 60000
    minEvictableIdleTimeMillis: 300000
    validationQuery: SELECT 1 FROM DUAL
    testWhileIdle: true
    testOnBorrow: false
    testOnReturn: false
    poolPreparedStatements: true
 
    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入
    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority
    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j
    filters: stat,wall,log4j
    maxPoolPreparedStatementPerConnectionSize: 20
    useGlobalDataSourceStat: true
    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500
```

4. 导入Log4j 的依赖

```xml
<!-- https://mvnrepository.com/artifact/log4j/log4j -->
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.17</version>
</dependency>
```

5. 并在resource目录下新建log4j.properties配置文件

```properties
#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码
log4j.rootLogger=DEBUG,console,file

#控制台输出的相关设置
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.Target = System.out
log4j.appender.console.Threshold=DEBUG
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=[%c]-%m%n

#文件输出的相关设置
log4j.appender.file = org.apache.log4j.RollingFileAppender
log4j.appender.file.File=./log/lin.log
log4j.appender.file.MaxFileSize=10mb
log4j.appender.file.Threshold=DEBUG
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n

#日志输出级别
log4j.logger.org.mybatis=DEBUG
log4j.logger.java.sql=DEBUG
log4j.logger.java.sql.Statement=DEBUG
log4j.logger.java.sql.ResultSet=DEBUG
log4j.logger.java.sql.PreparedStatement=DEBUG
```

## 2、配置DruidDataSource

1. 创建DuridConfig文件（config目录），为 DruidDataSource **绑定**全局配置文件中（application.yaml）的参数，再添加到容器中（不使用SpringBoot自动生成）

```java
@Configuration
public class DruidConfig {

      /*
       将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建
       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效
       @ConfigurationProperties(prefix = "spring.datasource")：作用就是将 全局配置文件中
       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中,
       DruidDataSource extends DruidAbstractDataSource，DruidAbstractDataSource源码中有同名参数
     */
    @ConfigurationProperties(prefix = "spring.datasource")
    @Bean
    public DataSource druidDataSource(){
        return new DruidDataSource();
    }
}
```

这和之前讲的SpringBoot配合MVC的实现，需要配置MyInterceptor、MyLocaleResolver、MyMvcConfig这些，需要先@configuration、@Bean；

2. 测试类中测试一下druidDataSource

```java
@SpringBootTest
class SpringBoot05JdbcApplicationTests {

    @Autowired
    DataSource dataSource;
    @Test
    void contextLoads() throws SQLException {
        //看一下默认数据源
        System.out.println(dataSource.getClass());

        //获得连接
        Connection connection = dataSource.getConnection();
        System.out.println(connection);

        DruidDataSource druidDataSource = (DruidDataSource) dataSource;
        System.out.println("druidDataSource 数据源最大连接数：" + druidDataSource.getMaxActive());
        System.out.println("druidDataSource 数据源初始化连接数：" + druidDataSource.getInitialSize());

        //关闭连接
        connection.close();

    }

}
```

## 3、配置Druid数据源监控

> Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看;即有一个默认的后台网页
>
> 由于内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 使用构造器注册 Servlet 方式。

1. 在DruidConfig中配置Druid数据源监控（固定写法）

```java
    @Bean	//注册到SpringBoot容器中
    public ServletRegistrationBean statViewServlet(){

        //内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式,这是通过构造器注册
        ServletRegistrationBean<StatViewServlet> bean = new ServletRegistrationBean<>(new StatViewServlet(), "/druid/*");

```

2. 并配置Druid的后台界面（账号、密码等）——和第一步在同一个方法中

```java
       //后台登录操作，账号密码配置

        // 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet
        // 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到
        HashMap<String, String> initParams = new HashMap<>();//键值对，所以第一个key值都是固定好的
        initParams.put("loginUsername", "admin"); //后台管理界面的登录账号；第一个参数是固定的
        initParams.put("loginPassword", "123456"); //后台管理界面的登录密码；第一个参数是固定的

        //后台允许谁可以访问
        //initParams.put("allow", "localhost")：表示只有本机可以访问
        //initParams.put("allow", "")：为空或者为null时，表示允许所有访问
        initParams.put("allow", "");
        // 后台拒绝谁访问
        //initParams.put("kuangshen", "192.168.1.20");表示禁止此ip访问


        //设置初始化参数
        bean.setInitParameters(initParams);
        return bean;
    }
```

- 测试效果：访问http://localhost:8080/druid/login.html（http://localhost:8080/druid）

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220115112446.png)

![查询一条sql，被监控到](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220115113059.png)

## 4、配置 Druid web 监控 filter 过滤器

1. 在DruidConfig中配置filter

```java
    //WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计
    @Bean
    public FilterRegistrationBean webStatFilter(){
        FilterRegistrationBean<Filter> bean = new FilterRegistrationBean<>();
        bean.setFilter(new WebStatFilter());


        Map<String, String> initParams = new HashMap<>();
        //exclusions：设置哪些请求进行过滤排除掉，从而不进行统计
        initParams.put("exclusions", "*.js,*.css,/druid/*,/jdbc/*");

        //设置初始化参数
        bean.setInitParameters(initParams);

        //"/*" 表示过滤所有请求
        //这个也是固定套路，FilterRegistrationBean除了注册过滤器TimeFilter外还通过setUrlPatterns方法配置了URL匹配规则。
        bean.setUrlPatterns(Arrays.asList("/*"));
        return bean;
    }
```

# 三、SpringBoot继承MyBatis

## 1、预备工作

1. 创建SpringBoot项目，添加starter——JDBC API、MySQL Driver、Spring Web
2. 配置yaml链接数据库信息（注意添加Druid到pom文件中；然后可以选加上一些druid的配置）

```yaml
 spring:
  datasource:
    username: root
    password: 123456
    #?serverTimezone=UTC解决时区的报错
    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
```

3. 加上MyBatis的依赖starter

```xml
<!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter -->
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.2.0</version>
</dependency>

```

4. 编写测试类（test目录）

```java
    @Autowired
    DataSource dataSource;
    @Test
    void contextLoads() throws SQLException {
        //看一下默认数据源
        System.out.println(dataSource.getClass());

        //获得连接
        Connection connection = dataSource.getConnection();
        System.out.println(connection);
        //关闭连接
        connection.close();
```

PS：额外的配置

1. 导入 Lombok

2. 整合MyBatis的一些别名和映射

```yaml
mybatis:
  type-aliases-package: com.kuang.pojo
  mapper-locations: classpath:mybatis/mapper/*.xml
```

## 2、mybatis配置

> 上面已经配置了依赖包、数据库链接、和基本的映射文件。后面的操作就是MVC的实现，一模一样，只不过mapper的位置变成了上面的classpath:mybatis/mapper/*.xml。

1. 创建实体类

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Department {
 
    private Integer id;
    private String departmentName;
 
}
```

2. 创建mapper目录，注解@Mapper，去被发现；@Repository表示装配mapper

```java
//@Mapper : 表示本类是一个 MyBatis 的 Mapper
@Mapper
@Repository
public interface DepartmentMapper {
 
    // 获取所有部门信息
    List<Department> getDepartments();
 
    // 通过id获得部门
    Department getDepartment(Integer id);
 
}
```

3. 对应的Mapper映射文件（位置在resources/mapper/UserMapper.xml）——现在sql语句

```java

<mapper namespace="com.kuang.mapper.DepartmentMapper">
 
    <select id="getDepartments" resultType="Department">
       select * from department;
    </select>
 
    <select id="getDepartment" resultType="Department" parameterType="int">
       select * from department where id = #{id};
    </select>
 
</mapper>
```

注意：之前的maven配置资源过滤问题（不需要了，因为 xxxMapper.xml写在了resource目录下）

5. 编写Controller，要用@Autowired装配上mapper

```java
 
@RestController
public class DepartmentController {
    
    @Autowired
    DepartmentMapper departmentMapper;
    
    // 查询全部部门
    @GetMapping("/getDepartments")
    public List<Department> getDepartments(){
        return departmentMapper.getDepartments();
    }
 
    // 查询全部部门
    @GetMapping("/getDepartment/{id}")
    public Department getDepartment(@PathVariable("id") Integer id){
        return departmentMapper.getDepartment(id);
    }
    
}
```

后面就是在controller中添加功能了，所以可以看到SpringBoot对于Mybatis的继承非常完备，基本就是MVC的框架，然后有@Mapper、@Autowired这两个实现连接即可。

# 三、SpringSecurity集成Spring Security 

> 安全框架市面上存在比较有名的：Shiro，Spring Security 

## 1、简介

- Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。
- Spring Security是一个框架，侧重于为Java应用程序提供**授权（Authorization）和身份认证（Authentication）。**
- 在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。
- 在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。

## 2、用户登录与注销

> 本质上和过滤器是很类似的。由于spring的核心思想是<font color='red'>“AoP横切”</font>，这里也一样，对于Spring Security的配置不需要对于业务层的代码进行修改。
>
> 参考官网：https://spring.io/projects/spring-security

记住几个类：

- WebSecurityConfigurerAdapter：自定义Security策略（用于被继承）
- AuthenticationManagerBuilder：自定义认证策略（用于被继承）
- @EnableWebSecurity：开启WebSecurity模式（这个注解一点要有）

### 1).  用户登录

1. 编写基础配置类（Config目录下）

```java
@EnableWebSecurity // 开启WebSecurity模式
public class SecurityConfig extends WebSecurityConfigurerAdapter {
 
   @Override
   protected void configure(HttpSecurity http) throws Exception {
       
  }
}
```

2. 定制请求的授权规则（configure有很多参数可以被重写，这里注意参数是HttpSecurity）

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
   // 定制请求的授权规则
   // 首页所有人可以访问；功能页只有相应的角色可以访问
   http.authorizeRequests().antMatchers("/").permitAll()
  .antMatchers("/level1/**").hasRole("vip1")
  .antMatchers("/level2/**").hasRole("vip2")
  .antMatchers("/level3/**").hasRole("vip3");
    // 开启自动配置的登录功能，作用：
// 没有认证，/login 请求来到登录页  springboot默认自动请求/login，并自动生成一个登陆页面  
// /login?error表示登录失败，认证失败就会重定向回登录页
http.formLogin();
}
```

测目前没有登录的角色，**因为请求需要登录的角色拥有对应的权限**才可以！

3. 重写认证方法configure(AuthenticationManagerBuilder auth)，为用户配置相应的角色。（也是在上面的类中）

```java
//定义认证规则
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
   
   //在内存中定义，也可以在jdbc数据库中去拿.... auth.jdbcAuthentication()...,正常应该从数据库中读
   auth.inMemoryAuthentication()
          .withUser("kuangshen").password("123456").roles("vip2","vip3")
          .and()
          .withUser("root").password("123456").roles("vip1","vip2","vip3")
          .and()
          .withUser("guest").password("123456").roles("vip1","vip2");
}
```

注意：这里的添加用户，用的是`.and().`拼接！

测试一下：访问localhost:8080/login;发现报错，There is no PasswordEncoder mapped for the id “null”——说明需要对密码加密

4. 修改上面的认证规则

```java
//定义认证规则
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
   //在内存中定义，也可以在jdbc中去拿....
   //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。
   //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密
   //spring security 官方推荐的是使用bcrypt加密方式。
   
   auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())
          .withUser("kuangshen").password(new BCryptPasswordEncoder().encode("123456")).roles("vip2","vip3")
          .and()
          .withUser("root").password(new BCryptPasswordEncoder().encode("123456")).roles("vip1","vip2","vip3")
          .and()
          .withUser("guest").password(new BCryptPasswordEncoder().encode("123456")).roles("vip1","vip2");
}
```

### 2).  用户注销

1. index.html中增加一个注销按钮，发送请求到后端

```html
<a class="item" th:href="@{/logout}">
   <i class="address card icon"></i> 注销
</a>
```

2. 开启自动配置好的注销功能，加在configure(HttpSecurity http)方法的最末尾

```
//定制请求的授权规则
@Override
protected void configure(HttpSecurity http) throws Exception {
   //....
   //开启自动配置的注销的功能
                        //只要我们请求/logout，就会注销
   http.logout();
}
```

- 测试效果：

![跳转到登录页](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220116112241.png)

改进一下， 注销成功后，直接跳转到首页（然后点击登录按钮，才到登录页）

```java
// .logoutSuccessUrl("/"); 注销成功来到首页
http.logout().logoutSuccessUrl("/");
```

## 3、用户权限控制（前端）

> 这里的功能主要是由前端实现。
>
> 用户没有登录的时候，导航栏上只显示登录按钮
>
> 用户登录之后，导航栏可以显示登录的用户信息及注销按钮！比如kuangshen这个用户，它只有 vip2，vip3功能，那么登录则只显示这两个功能，而vip1的功能菜单不显示！

我们需要结合thymeleaf中的一些功能：

- sec：authorize="isAuthenticated()":是否认证登录！
- sec:authorize="hasRole('vip1')"判断角色权限！
- 
   `用户名：<span sec:authentication="principal.username"></span>  //取到用户名`
- `角色：<span sec:authentication="principal.authorities"></span>  //取到角色`

1. 导入Maven依赖（thymeleaf和springsecurity5的整合包可以完成这个需求）

```xml
<!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 -->
<dependency>
   <groupId>org.thymeleaf.extras</groupId>
   <artifactId>thymeleaf-extras-springsecurity5</artifactId>
   <version>3.0.4.RELEASE</version>
</dependency>
```

2. 修改html文件头，导入Thymeleaf的命名空间

```
xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity5"
```

3. 修改导航栏，增加认证判断（三个div）：

```html
   <!--如果未登录-->
   <div sec:authorize="!isAuthenticated()">  //没有认证
       <a class="item" th:href="@{/login}">
           <i class="address card icon"></i> 登录
       </a>
   </div>
 
   <!--如果已登录--> 
   <div sec:authorize="isAuthenticated()">    //已认证
       <a class="item">
           <i class="address card icon"></i>
          用户名：<span sec:authentication="principal.username"></span>  //取到用户名
          角色：<span sec:authentication="principal.authorities"></span>  //取到角色
       </a>
   </div>
 
   <div sec:authorize="isAuthenticated()">    //已认证
       <a class="item" th:href="@{/logout}">
           <i class="address card icon"></i> 注销
       </a>
   </div>
```

4. 修改html的body，为之前的内容增加一个角色判断，实现菜单的动态显示（菜单的动态显示实现，使用sec:authorize="hasRole('vip1')"）

```html

<!-- sec:authorize="hasRole('vip1')" -->
<div class="column" sec:authorize="hasRole('vip1')">
   <div class="ui raised segment">
       <div class="ui">
           <div class="content">
               <h5 class="content">Level 1</h5>
               <hr>
               <div><a th:href="@{/level1/1}"><i class="bullhorn icon"></i> Level-1-1</a></div>
               <div><a th:href="@{/level1/2}"><i class="bullhorn icon"></i> Level-1-2</a></div>
               <div><a th:href="@{/level1/3}"><i class="bullhorn icon"></i> Level-1-3</a></div>
           </div>
       </div>
   </div>
</div>
```

vip2、vip3都一样，加一行代码就行了！

- 测试效果（进入http://www.localhost:8080/login输入kuangshen/123456登录）：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220116113220.png)

- 注意：如果注销404了，就是因为它默认防止csrf跨站请求伪造，可以将请求改为post表单提交，或者在spring security中关闭csrf功能；我们试试：在 配置中增加 **（一般应该不会遇到遇到）**:

```
http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求
http.logout().logoutSuccessUrl("/");
```

## 4、PS：记住我功能和首页定制

> 记住我：本质上就是实现了一个cookie功能
>
> 首页定制：就是注销后，回到的是我们自己做的主页index.html，不是spring security自带的login界面

### 1). 记住我功能

> spring security已经有这个功能了

1. 开启功能（也是放在configure(HttpSecurity http)方法中）

```java
//定制请求的授权规则
@Override
protected void configure(HttpSecurity http) throws Exception {
//。。。。。。。。。。。
   //记住我
   http.rememberMe();
}
```

我们**登录之后关闭浏览器，**然后重新打开浏览器访问，发现用户依旧存在！

### 2). 首页定制功能

> 源码注释：参数接受默认是username和password，请求默认走/login等等，源码注释多看！

1. 在刚才的登录页配置后面指定 loginPage（定制登录页）,这里指定的是请求（会访问localhost:8080/toLogin），不是toLogin.html

```java
http.formLogin().loginPage("/toLogin");
```

2. 前端也需要指向我们自己定义的 login请求

```html
<a class="item" th:href="@{/toLogin}">
   <i class="address card icon"></i> 登录
</a>
```

3. 配置我们的login.html 提交请求，<font color='red'>方式必须为post</font>:

```html
<form th:action="@{/login}" method="post">
   <div class="field">
       <label>Username</label>
       <div class="ui left icon input">
           <input type="text" placeholder="Username" name="username">
           <i class="user icon"></i>
       </div>
   </div>
   <div class="field">
       <label>Password</label>
       <div class="ui left icon input">
           <input type="password" name="password">
           <i class="lock icon"></i>
       </div>
   </div>
   <input type="submit" class="ui blue submit button"/>
</form>
```

这里我们提交的url请求还是之前的`th:action="@{/login}"`（会访问到默认的登录界面），即localhost:8080/login，但是由于我们在前面已经修改了登录页配置（到了/toLogin界面），这里就会报错！

两种解决方法：

- 要么把`th:action="@{/login}"`改为`th:action="@{/toLogin}"`，这样就能被接收到
- 要么配置接收登录的用户名和密码的参数！

```
http.formLogin()
  .usernameParameter("username")
  .passwordParameter("password")
  .loginPage("/toLogin")
  .loginProcessingUrl("/login"); // 登陆表单提交请求/login，所以login.html代码请求地址为/login
```

注意：上面的usernameParameter要和表单中提交上来的name属性一致！否则就接受不到！

整合一下：SecurityConfig

```java
package com.kuang.config;
 
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
 
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
 
   //定制请求的授权规则
   @Override
   protected void configure(HttpSecurity http) throws Exception {
 
       http.authorizeRequests().antMatchers("/").permitAll()
      .antMatchers("/level1/**").hasRole("vip1")
      .antMatchers("/level2/**").hasRole("vip2")
      .antMatchers("/level3/**").hasRole("vip3");
 
 
       //开启自动配置的登录功能：如果没有权限，就会跳转到登录页面！
           // /login 请求来到登录页
           // /login?error 重定向到这里表示登录失败
       http.formLogin()
          .usernameParameter("username")
          .passwordParameter("password")
          .loginPage("/toLogin")
          .loginProcessingUrl("/login"); // 登陆表单提交请求
 
       //开启自动配置的注销的功能
           // /logout 注销请求
           // .logoutSuccessUrl("/"); 注销成功来到首页
 
       http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求
       http.logout().logoutSuccessUrl("/");
 
       //记住我
       http.rememberMe().rememberMeParameter("remember");
  }
 
   //定义认证规则
   @Override
   protected void configure(AuthenticationManagerBuilder auth) throws Exception {
       //在内存中定义，也可以在jdbc中去拿....
       //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。
       //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密
       //spring security 官方推荐的是使用bcrypt加密方式。
 
       auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())
              .withUser("kuangshen").password(new BCryptPasswordEncoder().encode("123456")).roles("vip2","vip3")
              .and()
              .withUser("root").password(new BCryptPasswordEncoder().encode("123456")).roles("vip1","vip2","vip3")
              .and()
              .withUser("guest").password(new BCryptPasswordEncoder().encode("123456")).roles("vip1","vip2");
  }
}
```

# 四、SpringSecurity集成Shiro 

## 1、简介

Apache Shiro是一个强大且易用的Java安全框架

可以完成**身份验证、授权、密码和会话管理**

Shiro 不仅可以用在 JavaSE 环境中，也可以用在 JavaEE 环境中

官网： http://shiro.apache.org/

功能：基本和spring security一致；也有一些新的东西，比如：

- **Caching**：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；

- **Concurrency**：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；

<font color='red'>核心流程：</font>

![Apache Shiro | Simple. Java. Security.](https://shiro.apache.org/assets/images/ShiroBasicArchitecture.png)

应用代码直接交互的对象是Subject，也就是说Shiro的对外API核心就是Subject；其每个API的含义：

- **Subject**：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者；
- **SecurityManager**：安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互，如果学习过SpringMVC，你可以把它看成DispatcherServlet前端控制器；
- **Realm**：域，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。

和工厂模式是很类似的概念。

## 2、预备工作

> 导入官网的快速入门项目：shiro/samples/quickstart/
>
> 项目地址：https://github.com/apache/shiro/tree/main/samples/quickstart

1. 新建一个 **Maven 工程**（别搞错了！不是SpringBoot项目），删除其 src 目录，将其作为父工程

2. 导入依赖（shiro默认的日志支持是org/apache/commons-logging，但是我们这里用的是log4j）

```xml
<dependencies>
        <dependency>
            <groupId>org.apache.shiro</groupId>
            <artifactId>shiro-core</artifactId>
            <version>1.4.1</version>
        </dependency>
 
        <!-- configure logging -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>jcl-over-slf4j</artifactId>
            <version>1.7.21</version>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-log4j12</artifactId>
            <version>1.7.21</version>
        </dependency>
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.17</version>
        </dependency>
    </dependencies>
```

3. 把快速入门案例中的 resource 下的log4j.properties 复制下来

```properties
log4j.rootLogger=INFO, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n

# General Apache libraries
log4j.logger.org.apache=WARN

# Spring
log4j.logger.org.springframework=WARN

# Default Shiro logging
log4j.logger.org.apache.shiro=INFO

# Disable verbose logging
log4j.logger.org.apache.shiro.util.ThreadContext=WARN
log4j.logger.org.apache.shiro.cache.ehcache.EhCache=WARN
```

4. 导入shiro.ini配置文件（配置用户映射和角色）

```ini
[users]
# user 'root' with password 'secret' and the 'admin' role
root = secret, admin
# user 'guest' with the password 'guest' and the 'guest' role
guest = guest, guest
# user 'presidentskroob' with password '12345' ("That's the same combination on
# my luggage!!!" ;)), and role 'president'
presidentskroob = 12345, president
# user 'darkhelmet' with password 'ludicrousspeed' and roles 'darklord' and 'schwartz'
darkhelmet = ludicrousspeed, darklord, schwartz
# user 'lonestarr' with password 'vespa' and roles 'goodguy' and 'schwartz'
lonestarr = vespa, goodguy, schwartz

# -----------------------------------------------------------------------------
# Roles with assigned permissions
#
# Each line conforms to the format defined in the
# org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc
# -----------------------------------------------------------------------------
[roles]
# 'admin' role has all permissions, indicated by the wildcard '*'
admin = *
# The 'schwartz' role can do anything (*) with any lightsaber:
schwartz = lightsaber:*
# The 'goodguy' role is allowed to 'drive' (action) the winnebago (type) with
# license plate 'eagle5' (instance specific id)
goodguy = winnebago:drive:eagle5
```

5. 复制一下 Quickstart.java 文件

-- 有些包过时了，有些包没用到；要么替换要么删除。

## 3、分析Quickstart功能

1. 通过 SecurityUtils 获取当前执行的用户 Subject

```java
Subject currentUser = SecurityUtils.getSubject();
```

2. 通过 当前用户拿到 Session

```java
Session session = currentUser.getSession();
```

3. 用 Session 存值取值

```javascript
session.setAttribute("someKey", "aValue");



        String value = (String) session.getAttribute("someKey");
```

4. 判断用户是否被认证

```undefined
currentUser.isAuthenticated()
```

5. 执行登录操作

```undefined
 currentUser.login(token);
```

6. 打印其标识主体

```undefined
currentUser.getPrincipal()
```

7. 注销

```undefined
currentUser.logout();
```

运行一下，看一下输出：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220116194950.png)

## 4、在SpringBoot中整合Shiro

### 1). 在上面的父项目中新建SpringBoot module（加上web、Thymeleaf依赖）

### 2). 导入SpringBoot对Shiro 整合包的依赖

```
<!--SpringBoot 和 Shiro 整合包-->
		<!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-spring-boot-web-starter -->
		<dependency>
			<groupId>org.apache.shiro</groupId>
			<artifactId>shiro-spring-boot-web-starter</artifactId>
			<version>1.6.0</version>
		</dependency>
```

### 3). **编写Shiro的核心配置文件——三大要素（重要）**

- 用户\==subject -> ShiroFilterFactoryBean
- 管理所有用户\=\==securityManager -> DefaultWebSecurityManager
- 连接数据==realm

因此，创建config/ShiroConfig：

```
//创建ShiroFilterFactoryBean

//DefaultWebSecurityManager

//创建Realm 对象
```

从上到下的流程，但是实际操作中对象创建的顺序 ： realm -> securityManager -> subject

1. 编写自定义的 realm ，需要继承 AuthorizingRealm

```java
//自定义的 Realm
public class UserRealm extends AuthorizingRealm {
    //授权
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        //打印一个提示
        System.out.println("执行了授权方法");
        return null;
    }

    //认证
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        //打印一个提示
        System.out.println("执行了认证方法");
        return null;
    }
}
```

然后在ShiroConfig文件中注入realm对象（横切的思想）：

```java
    //创建Realm 对象
	//让 spring 托管自定义的 realm 类
    @Bean
    public UserRealm userRealm(){
        return new UserRealm();   
    }
```

2. 绑定realm到manager

```java
    //DefaultWebSecurityManager
    @Bean(name = "securityManager")
    public DefaultWebSecurityManager defaultWebSecurityManager(@Qualifier("userRealm") UserRealm userRealm){
        DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager();
        //关联realm
        defaultWebSecurityManager.setRealm(userRealm);

        return defaultWebSecurityManager;
    }
```

<font color='red'>解决一个报错：</font>

```
Description:

No bean of type 'org.apache.shiro.realm.Realm' found.

Action:

Please create bean of type 'Realm' or add a shiro.ini in the root classpath (src/main/resources/shiro.ini) or in the META-INF folder (src/main/resources/META-INF/shiro.ini).
```

提示的意思很简单，就是没找到这个Realm。Realm只在ShiroConfig中创建，说明ShiroConfig没装配上，检查一下代码，发现少了一个注解@Configuration。。。一个小问题

一个新的知识点——@Qualifier("userRealm") ：

- 接收spring容器中对应名字的实体对象（就是上面userRealm()方法中的创建的实体类）
- spring 默认的 BeanName 就是方法名
- @Bean(name = "XXX")：name 属性 指定 BeanName

3. 创建工厂

```java
    //创建ShiroFilterFactoryBean
    @Bean
    public ShiroFilterFactoryBean shiroFilterFactoryBean(@Qualifier("securityManager") DefaultWebSecurityManager defaultWebSecurityManager){
        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();
        //设置安全管理器
        bean.setSecurityManager(defaultWebSecurityManager);
        return bean;
    }
```

ok！预配置结束了，现在可以去实现具体业务

## 5、Shiro实现用户登陆拦截&用户认证

### 1). 搭建简单测试环境

1. 新建一个首页

```html
<h1>首页</h1>
<h1 th:text="${msg}"></h1>
<a th:href="@{/user/add}">add</a>
<hr>
<a th:href="@{/user/update}">update</a>
```

2. 新建一个登录页面

```html
<H1>登录页面</H1>
<form >
    用户名<input type="text" name="username">
    密码<input type="password" name="password">
    <input type="submit">
</form>
```

​	3.1 新建一个增加用户页面(只是为了演示跳转)

```
<h1>add</h1>
```

​	3.2 新建一个更新用户页面

```
<h1>update</h1>
```

4. 编写对应的Controller

```java
@Controller
public class HelloTest {
    @RequestMapping({"/","index"})
    public String index(Model model){
        model.addAttribute("msg","helloWorld,Shiro!");
        return "index";
    }

    @RequestMapping("/user/add")
    public String add(){
        return "user/add";
    }


    @RequestMapping("/user/update")
    public String update(){
        return "user/update";
    }
    @RequestMapping("/tologin")
    public String login() {
        return "login";
    }

}
```

- 文件夹位置：

```
+templates
	+user
		add.html
		update.html
	+login.html
	+index.html
```

- <font color='red'>注意以下问题：</font>

```
关于SpringBoot下template文件夹下html页面访问的一些问题：
```

- springboot整合了springmvc的拦截功能。拦截了所有的请求。默认放行的资源是：resources/static/ 目录下所有静态资源。（不走controller控制器就能直接访问到资源）。
  html页面如果**放在resources/templates目录（我们就是要放到这里）**下，则需要走controller控制器，controller放行，允许该资源访问，该资源才能被访问到。否则就会报404错误（它不可以直接被访问）。

### 2). 添加拦截&认证

####  登录拦截

> 在上面的 shiroFilterFactoryBean方法中加上需要拦截的登录请求

```java
    //创建ShiroFilterFactoryBean
    @Bean
    public ShiroFilterFactoryBean shiroFilterFactoryBean(@Qualifier("securityManager") DefaultWebSecurityManager defaultWebSecurityManager){
        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();
        //设置安全管理器
        bean.setSecurityManager(defaultWebSecurityManager);


    //添加 Shiro 的内置过滤器=======================
        /*
            anon : 无需认证，就可以访问
            authc : 必须认证，才能访问
            user : 必须拥有 “记住我”功能才能用
            perms : 拥有对某个资源的权限才能访问
            role : 拥有某个角色权限才能访问
         */
        LinkedHashMap<String, String> map = new LinkedHashMap<>();
        // 设置 /user/addUser 这个请求,只有认证过才能访问
        //        map.put("/user/addUser","authc");
        //        map.put("/user/deleteUser","authc");
        // 设置 /user/ 下面的所有请求,只有认证过才能访问
        map.put("/user/*","authc");
        bean.setFilterChainDefinitionMap(map);
        // 设置登录的请求
        bean.setLoginUrl("/tologin");

        return bean;
    }
```

测试：点击 index中的add链接，不会跳到 add页面，而是跳到登录页，拦截成功！

#### 用户认证

1. 在 Controller 中新增一个登录的Controller

```java
    @RequestMapping("/login")
    public String login(String username, String password, Model model) {
        //获取当前用户
        Subject subject = SecurityUtils.getSubject();
        //没有认证过
        //封装用户的登录数据,获得令牌
        UsernamePasswordToken token = new UsernamePasswordToken(username, password);
        System.out.println("执行了获取token方法");
        //登录 及 异常处理
        try {
            //用户登录
            subject.login(token);  //这句代码底层调用了UserRealm 中的 AuthenticationInfo 
            return "index";
        } catch (UnknownAccountException uae) {
            //如果用户名不存在
            System.out.println("账户不存在");
            model.addAttribute("exception", "账户不存在");
            return "login";
        } catch (IncorrectCredentialsException ice) {
            //如果密码错误
            System.out.println("密码错误");
            model.addAttribute("exception", "密码错误");
            return "login";
        }
    }
```

- 用抛出异常的思想解决~
- 注意，这里的操作其实就是模仿的QuickStart实现的，是一模一样的！
- 这里 subject.login(token); 调用了UserRealm 中的 AuthenticationInfo；然后我们就要去比较这个和我们设置的值是否一致了！

2. 修改 UserRealm 中的 AuthenticationInfo

```java
@Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        //打印一个提示
        System.out.println("执行了认证方法");
 
        // 用户名密码(暂时先自定义一个做测试)
        String name = "root";
        String password = "1234";
 
        //通过参数获取登录的控制器中生成的 令牌
        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;
        //用户名认证
        if (!token.getUsername().equals(name)){
            // return null 就表示控制器中抛出的相关异常
            return null;
        }
        //密码认证， Shiro 自己做，为了避免和密码的接触
        //最后返回一个 AuthenticationInfo 接口的实现类，这里选择 SimpleAuthenticationInfo
        // 三个参数：获取当前用户的认证 ； 密码 ； 认证名
        return new SimpleAuthenticationInfo("", password, "");
    }
```

- 密码认证， Shiro 自己做，为了避免和密码的接触
- 返回SimpleAuthenticationInfo，这块对比逻辑是先对比username，但是username肯定是相等的，所以真正对比的是password。从这里传入的password（这里是从数据库获取的）和token（filter中登录时生成的）中的password做对比，如果相同就允许登录，不相同就抛出异常。

3. 顺带修改一下login.html

> 增加表单提交操作和异常提示信息

```
<H1>登录页面</H1>
<form th:action="@{/login}">
  用户名<input type="text" name="username">
  密码<input type="password" name="password">
  <input type="submit">
</form>
<p th:text="${exception}" style="color: crimson"></p>
```

- 测试效果：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20220121164643.png)

### 3). 退出登录

> 在控制器中添加一个realm退出登录的方法

```java
//退出登录
@RequestMapping("/logout")
public String logout(){
    Subject subject = SecurityUtils.getSubject();
    subject.logout();
    return "login";
}
```

同样地，在index.html中增加一个按钮：

```html
<h1>首页</h1>
<h1 th:text="${msg}"></h1>
<a th:href="@{/user/add}">add</a>
<hr>
<a th:href="@{/user/update}">update</a>
<form th:action="@{/logout}">
    <input type="submit"  value="退出登录"></input>
</form>
```

## 6、Shiro整合数据库

> 这一步其实没啥好说的，都是重复的过程。我在这里把大致流程整理下，然后把关键步骤突出一下

1. 导入 Mybatis 相关依赖

2. 编写配置文件——application.yml连接Mysql配置，及log4j配置文件

3. 编写mybatis的配置——别名设置，mapper映射文件位置

4. 编写实体类 ,引入Lombok

5. 编写Mapper接口

6. 编写Mapper配置文件，关联上面的接口

7. 编写UserService 层，@Autowired去装配上上面的mapper操作

8. <font color='red'> 改造UserRealm，连接到数据库进行真实的操作</font>

   1. doGetAuthorizationInfo方法——没有变化
   2. doGetAuthenticationInfo——替换为从数据库中获得信息

   ```java
   //真实连接数据库
   user user = userservice.queryUserByName(userToken.getUsername());
   if (user == null){
   	//用户名不存在
   	return null;//shiro底层就会抛出异常UnknownAccountException
   }
   ```

9. ShiroConfig.java、controller.java不变

## PS：用户授权操作

1. 在shiroFilterFactoryBean方法中加入授权代码

```java
        //授权过滤器
        map.put("/user/add","perms[user:add]");    //perms : 拥有对某个资源的权限才能访问
        bean.setUnauthorizedUrl("/unauth");   //在shiroFilterFactoryBean中配置一个未授权的请求页面！不配置的话，shiro会自动跳转到未授权界面，但是我们没有这个界面，所以会报错401


        map.put("/user/*","authc");
        bean.setFilterChainDefinitionMap(map);
        // 设置登录的请求
        bean.setLoginUrl("/tologin");
        return bean;
```

<font color='red'>注意：这里的授权过滤要放在认证过滤之前！！！</font>

2. 修改Controller，增加`/noauth`的请求处理

```java
    @RequestMapping("/unauth")
    @ResponseBody
    public String noauth(){
        return "未授权不能访问";	//ResponseBody返回字符串
    }

```

- 或者这里用@RestMapping

- 测试效果：进入首页，点击add，弹出登录框，登录成功，返回index页面，然后点击add（因为没有权限），页面跳转提示：“未授权不能访问”

3. 在UserRealm的doGetAuthorizationInfo方法中添加赋值

```java
    //授权
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        //打印一个提示
        System.out.println("执行了授权方法");
        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
        info.addStringPermission("user:add");
        return info;
    }
```

[这里可以看](https://segmentfault.com/a/1190000022564101)，针对QuickStart的授权分析！

## 7、SHiro整合Thymeleaf

1. 添加依赖（类似SpringSecurity的jar：thymeleaf-extras-springsecurity5）：

```java
        <dependency>
           <groupId>com.github.theborakompanioni</groupId>
            <artifactId>thymeleaf-extras-shiro</artifactId>
            <version>2.0.0</version>
        </dependency>
```

2. 配置一个shiro的Dialect ，在shiro的配置中增加一个Bean（必须要）

```java
//配置ShiroDialect：方言，用于 thymeleaf 和 shiro 标签配合使用 
@Bean 
public ShiroDialect getShiroDialect(){ 
    return new ShiroDialect(); 
}
```

3. **修改前端index.html——重要点**

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org" xmlns:shiro="http://www.thymeleaf.org/thymeleaf-extras-shiro">   
//导入thymeleaf-extras-shiro命名空间
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<h1>首页</h1>
<h1 th:text="${msg}"></h1>
 
<div th:if="${session.loginuser == null}">   //从session中取值进行判断，是否显示“登录”的按钮
<a th:href="@{tologin}">登录</a>
</div>
 
<div shiro:hasPermission="user:add">   //有权限才显示add链接
<a th:href="@{/user/add}">add</a>
</div>
 
<hr>
 
<div shiro:hasPermission="user:update">    //有权限才显示update链接
<a th:href="@{/user/update}">update</a>
</div>
 
 
</body>
 
</html>
```

在UserRealm类的doGetAuthenticationInfo方法中，加入session，用于上面的登录判断：

```java
//登录成功后加入session
Subject subject = SecurityUtils.getSubject();
Subject.getSession().setrAttribute("loginuser",user);
```

- 测试效果：登录的账户有什么权限就显示什么页面，登录成功后，登录按钮也不会再显示!

## 8、第三、四节的小结

对比SpringSecurity 和 Shiro 两个安全的框架，主要是想让大家多一些思路，其实什么都不用，我们靠拦截器也可以实现这些功能。

但是可能需要花费大量的时间和代码， 还有就是Bug 多，思考不全，而现在，我们两个框架都会使用了，也给大家**对比**的进行学习了，当然真实的工作中，可能代码会更加的复杂。（Shiro的可定制化程度更高）

多看源码，特别是这种国内公司的框架，其实源码写的都是中国人思维，稍微细心点就能看到它的目的！
