---
layout:     post
title:     JAVAweb01-基础
subtitle:   什么是java  web
date:       2021-11-25
author:     ldf
header-img: img/post-bg-javaweb01.jpg
catalog: true
tags:
    - javaWeb基础
    - java基础
    - code
---


><font size="5" color = "red">**JAVA WEB 和JavaEE的区别**</font>
>
>——写在前面：
>很多时候，这两个词是混用的！！
>**JavaEE：**全称Java平台企业版（Java Platform Enterprise Edition），是Sun公司为企业级应用推出的标准平台。JavaEE是个大杂烩，包括Applet、EJB、JDBC、JNDI、Servlet、JSP等技术的标准，运行在一个完整的应用服务器上，用来开发大规模、分布式、健壮的网络应用。 
>**JavaWeb：**主要指以Java语言为基础，利用JavaEE中的Servlet、JSP等技术开发动态页面，方便用户通过浏览器与服务器后台交互。Java Web应用程序可运行在一个轻量级的Web服务器中，比如Tomcat。 
>**可以粗略地认为JavaWeb就是JavaEE的一部分**

# JAVA WEB 基础

在Java Web学习中，有几个重点需要关注一下，分别是 **Servlet、Filter、Http**，也是这里的难点！其他的JSP、Maven只是相关工具，掌握即可！

这里的内容很多，涉及的东西也很杂，所以需要注意的细节有很多。本笔记只是用作入门，真实开发问题需要自己多动手实践！



## 1、基本概念

- 静态web
  - html,css
  - 提供给所有人看的数据始终不会发生变化！
- 动态web
  - 淘宝，几乎是所有的网站；
  - 提供给所有人看的数据始终会发生变化，每个人在不同的时间，不同的地点看到的信息各不相同！
  - 技术栈：Servlet/JSP，ASP，PHP

## 2、web服务器

#### 几种典型技术：

| 开发技术 | 推出年代 | 文件后缀    | 发展趋势 |
| -------- | -------- | ----------- | -------- |
| Java     | 1996年   | .war/.jar   | 好       |
| Python   | 1991年   | .py         | 好       |
| ASP      | 1996年   | .asp        | 一般     |
| ASP.NET  | 2001年   | .aspx/.asmx | 好       |
| JSP      | 1999年   | .jsp        | 一般     |
| PHP      | 1997年   | .php        | 一般     |
| Perl     | 1987年   | .pl/.pm     | 一般     |

以HelloWorld为例，用上述技术进行实现：

1. java

```java
@RestController
public class HelloController {
    @RequestMapping("/hello")
    public String hello(String name) {
        return "hello world from Java.";
    }
}
```

2. Python

```Python
#!/usr/bin/python
from http.server import HTTPServer, BaseHTTPRequestHandler

PORT_NUMBER = 8080

#This class will handles any incoming request from the browser 
class myHandler(BaseHTTPRequestHandler):

    #Handler for the GET requests
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type','text/html')
        self.end_headers()
        # Send the html message
        self.wfile.write(str.encode("Hello world from python."))
        return

if __name__ == '__main__':
    #Create a web server and define the handler to manage the incoming request
    server = HTTPServer(('', PORT_NUMBER), myHandler)
    print("Started httpserver on port: %s" % PORT_NUMBER)

    #Wait forever for incoming htto requests
    server.serve_forever()
```

3. ASP

```asp
<html>
    <head>
        <title>Test ASP Page</title>
        <meta http-equiv="Content-Type" content="text/html; charset=gb2312">
    </head>
    <body>
        <%="Hello world from ASP page."%><br>
        <% response.write("Hello world from ASP page.") %>
    </body>
</html>
```

4. JSP

```jsp
<html>
    <head>
        <title>Test JSP Page</title>
        <meta http-equiv="Content-Type" content="text/html; charset=gb2312">
    </head>
    <body>
        <%
        out.println("Hello world from JSP page.");
        %>
    </body>
</html>
```

5. PHP

```php
<html>
    <head>
        <title>Test PHP Page</title>
    </head>
    <body>
        <?php
        echo "Hello World from PHP page. \n";
        ?>
    </body>
</html>
```

#### 技术的对比分析

1. ASP基本一个页面都有几干行的业务代码，页面极其换乱。国内最早流行的就是ASP
2. PHP开发速度很快，功能很强大，跨平台，代码很简单（70%，WP），但是无法承载大量访问量（局限性）
3. jSP/Servlet：基于Java语言的。解决<font size= "4" color = "red">**高并发、高性能、高可用**</font>的问题



## 3、Tomcat

Tomcat是Apache 软件基金会（Apache Software Foundation)的jakarta项目中的一个核心项目，最新的Servlet 和JSP 规范总是能在Tomcat中得到体现，因为Tomcat 技术先进、性能稳定，而且免费，因而深受lava爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web应用服务器。

**Tomcat 实际上运行的是JSP页面和Servlet。**

### Tomcat安装

[详见](https://blog.csdn.net/yangxingpa/article/details/58174598)

### Tomcat启动和配置

文件结构：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211203193106.png)

### 启动、关闭Tomcat

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211203192848.png)

访问测试：浏览器输入：http://localhost:8080

### 一个面试题——网站访问的过程

1. 客户输入一个域名

2. 检测本机的C:\Windows\System32\drivers\etc\hosts配置文件下有没有这个域名映射

   1. 有：直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问

   ```text
   # localhost name resolution is handled within DNS itself.
   #	127.0.0.1       localhost
   #	::1             localhost
   ```

   ​    2. 没有：去DNS服务器(管理全世界的服务器域名)找，找到的话就返回，没有就返回找不到

### 发布一个web网站

将自己写的网站，放到服务器（Tomcat)中指定的web应用的文件夹（webapps)下，就可以访问了

**网站应该有的结构**

```
-- webapp : Tomcat服务器的web目录
	-ROOT
	-self : 网站的目录名
		-WEB-INF
			-classes ： Java程序
			-lib ： web应用依赖的jar包
			-web.xml ： 网站配置文件
		-index.html ： 默认的网页
		-static
			-css
				-style.css
			-js
			-img
		-...
```

## 4、Http

### 定义

- 超文本传输协议
- 请求-响应协议
- 通常运行在TCP之上
- 端口：80
- 请求行 + 消息头 组成

### 请求行

- 请求行中的请求方式：GET
- 请求方式：Get,Post,HEAD,DELETE,PUT,TRACT.…
  - get：请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效
  - post:请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效。

### 消息头

- Accept：告诉浏览器，它所支持的数据类型
- Accept-Encoding：支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1
- Accept-Language：告诉浏览器，它的语言环境
- Cache-Control：缓存控制
- Connection：告诉浏览器，请求完成是断开还是保持连接
- HOST：主机..../.

### 响应体

- Accept：告诉浏览器，它所支持的数据类型
- Accept-Encoding：支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1
- Accept-Language：告诉浏览器，它的语言环境
- Cache-Control：缓存控制
- Connection：告诉浏览器，请求完成是断开还是保持连接
- HOST：主机..../.
- Refresh：告诉客户端，多久刷新一次；
- Location：让网页重新定位；

### 响应状态码

- 200：请求响应成功200
- 3xx:请求重定向
  - 重定向：重新定位到新位置；
- 4xx:找不到资源404
  - 资源不存在；
- 5xx:服务器代码错误 500 502:网关错误

### 一道面试题

当你的浏览器中地址栏输入地址回车到展示页面，经历了什么？

- DNS解析：
            寻找资源所在的机器的过程，返回一个IP地址。递归和迭代解析，默认和使用较多的是递归。

- TCP连接：
             三次握手

- 发送HTTP请求：
             客服端向服务器发送请求，HTTP请求报文包括请求行、请求头部、请求体

- 服务器响应请求：
             服务器返还HTTP报文，包含响应行、响应头部、响应体。

- 浏览器解析：
             收到网页文件后进行解析，将资源呈现出来。

- 关闭TCP连接：
             四次握手。
  ————————————————
  原文链接：https://blog.csdn.net/qq_41794228/article/details/115702839

## 5、Maven

**目的：**自动导入jar依赖包

### 5.1 Maven项目结构

```ascii
a-maven-project
├── pom.xml
├── src
│   ├── main
│   │   ├── java
│   │   └── resources
│   └── test
│       ├── java
│       └── resources
└── target
```

项目的根目录`a-maven-project`是项目名，它有一个项目描述文件`pom.xml`，存放Java源码的目录是`src/main/java`，存放资源文件的目录是`src/main/resources`，存放测试源码的目录是`src/test/java`，存放测试资源的目录是`src/test/resources`，最后，所有编译、打包生成的文件都放在`target`目录里。这些就是一个Maven项目的标准目录结构。

**项目描述文件`pom.xml`，它的内容长得像下面：**

```xml
<project ...>
	<modelVersion>4.0.0</modelVersion>
	<groupId>com.itranswarp.learnjava</groupId>
	<artifactId>hello</artifactId>
	<version>1.0</version>
	<packaging>jar</packaging>
	<properties>
        ...
	</properties>
	<dependencies>
        <dependency>
            <groupId>commons-logging</groupId>
            <artifactId>commons-logging</artifactId>
            <version>1.2</version>
        </dependency>
	</dependencies>
</project>
```

### 5.2 xml文件配置方法

其中，`groupId`类似于Java的包名，通常是公司或组织名称，`artifactId`类似于Java的类名，通常是项目名称，再加上`version`，**一个Maven工程就是由`groupId`，`artifactId`和`version`作为唯一标识。**我们在引用其他第三方库的时候，也是通过这3个变量确定。例如，依赖`commons-logging`：

```xml
<dependency>
    <groupId>commons-logging</groupId>
    <artifactId>commons-logging</artifactId>
    <version>1.2</version>
</dependency>
```

使用`<dependency>`声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。

### 5.3 预配置MAVEN

#### 配置环境变量

**（1）新建系统变量**

变量名：Maven_Home

变量值：D:\xxxxx\apache-maven-3.6.3

**（2）修改Path变量值**

在Path变量值后面加上：;%Maven_Home%\bin;

   **(3)设置MAVEN_OPTS环境变量**
变量名：MAVEN_OPTS

变量值：-Xms128m -Xmx512m

**设置MAVEN_OPTS环境变量不是必须的，但建议设置。**因为Java默认的最大可用内存往往不能够满足Maven运行的需要，比如在项目较大时，使用Maven生成项目站点需要占用大量的内存，如果没有该配置，则很容易得到java.lang.OutOfMemeoryError。因此，一开始就配置该变量是推荐的做法。

#### 配置国内镜像

在Maven项目的conf/settings.xml文件中，加入

```xml
<mirror>
    <id>aliyunmaven</id>
    <mirrorOf>*</mirrorOf>
    <name>阿里云公共仓库</name>
    <url>https://maven.aliyun.com/repository/public</url>
</mirror>
```

#### 建立一个本地仓库

1. 新建一个Maven项目（地址随意）
   1. 选择`org.apache.maven.archetypes:maven-archetype-webapp`(不要选错)

2. 按顺序填入groupID、artifactId
3. 修改本地仓库地址

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211204220109.png)

4. 等待导入完成

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211204215743.png)

5. IDEA中的Maven设置

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211204220650.png)

<img src="https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211204222103.png" alt="这是只有在web应用中才有的" style="zoom:100%;" />



#### 创建一个普通的Maven项目

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211204221922.png)

#### 在IDEA中配置Tomcat

1. 点击idea的右上角的`edit(add) configurations...`
2. 找到并选择Tomcat Server；（在下面一点，往下拉）

<img src="https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211204223253.png" alt="一些配置信息" style="zoom:67%;" />

3. 解决warning：`No artifacts marked for deployment`

   主动添加一个deployment：war

<img src="https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211204224135.png" style="zoom:80%;" />

然后下面会显示一个`Application context:`这个是虚拟路径。一般默认为“/”，即直接访问localhost:8080;现在是需要访问localhost:8080/javaweb_01_maven_war

<img src="https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211204224226.png" style="zoom:80%;" />

4. 点击运行，弹出效果：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211205112407.png)

上面的内容就是index.jsp的内容

## 6、Servlet

### 6.1定义

- Servlet就是sun公司开发动态web的一门技术
- Sun在这些APi中提供一个接口叫做：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤：
  - 编写一个类，实现Serlet接口
  - 把开发好java类部署到web服务器中。

**把实现了Servlet接口的Java程序叫做，Servlet！！**

### 6.2 HelloServlet

1. 构建一个普通的Maven项目，删掉里面的的src目录，以后我们的学习就在这个项目里面建立Moduel；这个空的工程就题Maven主工程；

2. 关于Maven父子工程的理解；

   - 父项目中会有

   ```xml
     <modules>
         <module>servlet-01</module>
     </modules>
   ```

   

   - 子项目会有

```xml
    <parent>
        <artifactId>javaweb-02-servlet</artifactId>
        <groupId>com.kuang</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
```

父项目中的java子项目可以直接使用——`son extends father`

3. Maven环境优化
   1. 修改web.xml为最新的
   2. 将maven的结构搭建完整

4. 编写一个Servlet程序

   1. 编写一个普通类
   2. 实现Servlet接口，这里我们直接继承HttpServlet。调用过程如下：

   `Servlet接口 ——>GenericServlet ——>HttpServlet ——> 自己定义的类只需要继承HttpServlet`

```java
public class servlet extends HttpServlet {

    //由于get或者post只是请求实现的不同方式，可以相互调用，业务逻辑都一样
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //快捷键是alt + enter——>自动补全本地变量；
        PrintWriter writer = resp.getWriter(); //响应流
        
        writer.print("hello , Servlet");
        
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        super.doPost(req, resp);        //这里就是调用上面的get方法，所以这里基本就不会再被使用，不用动它；所有的修改在doGet方法中实现
    }
}
```

5. **编写一个Servlet的映射**

   ​        为什么要映射？  我们写的是java程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要在web服务器中注册我们写的Servlet，还需要给他一个浏览器能够访问的路径。


```xml
  <!--注册Servlet-->
  <servlet>
      <servlet-name>hello</servlet-name>
      <servlet-class>com.kuang.servlet.HelloServlet</servlet-class>
  </servlet>
  <!--Servlet的请求路径-->
  <servlet-mapping>
      <servlet-name>hello</servlet-name>
      <url-pattern>/hello</url-pattern>
  </servlet-mapping>
```

6. 配置Tomcat
   注意：配置项目发布的路径就可以了

7. 启动

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211205112257.png)

### 6.3Servlet原理

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200506180639329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70)

### 6.4 Mapping 问题

1. 一个Servlet可以指定一个映射路径

```xml
  <servlet-mapping>
      <servlet-name>hello</servlet-name>
      <url-pattern>/hello</url-pattern>
  </servlet-mapping>
```

2. 一个Servlet也可以制定多个映射路径

```xml
  <servlet-mapping>
      <servlet-name>hello</servlet-name>
      <url-pattern>/hello</url-pattern>
  </servlet-mapping>
  <servlet-mapping>
      <servlet-name>hello</servlet-name>
      <url-pattern>/hello2</url-pattern>
  </servlet-mapping>
  <servlet-mapping>
      <servlet-name>hello</servlet-name>
      <url-pattern>/hello3</url-pattern>
  </servlet-mapping>
  <servlet-mapping>
      <servlet-name>hello</servlet-name>
      <url-pattern>/hello4</url-pattern>
  </servlet-mapping>
  <servlet-mapping>
      <servlet-name>hello</servlet-name>
      <url-pattern>/hello5</url-pattern>
  </servlet-mapping>
```

3. 一个servlet也可以指定**通用映射**路径

```xml
  <servlet-mapping>
      <servlet-name>hello</servlet-name>
      <url-pattern>/hello/*</url-pattern>
  </servlet-mapping>
```

4. 默认请求路径（但是这样会**把主页覆盖掉，不建议这样做！！**）

```xml
   <!--默认请求路径-->
   <servlet-mapping>
       <servlet-name>hello</servlet-name>
       <url-pattern>/*</url-pattern>
   </servlet-mapping>
```

5. 指定一些后缀或者前缀等等…（注意点：*前面不能加项目映射的路径）

```xml
<!--可以自定义后缀实现请求映射
      注意点，*前面不能加项目映射的路径
      hello/sajdlkajda.qinjiang
      -->
<servlet-mapping>
    <servlet-name>hello</servlet-name>
    <url-pattern>*.qinjiang</url-pattern>
</servlet-mapping>

```

6. 优先级问题

   指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求；

   - 比如新建一个class文件——ErroServlet类，用于指定404的情况：

   ```java
   public class ErrorServlet extends HttpServlet {
       @Override
       protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
           //这里就是看原始的404网页请求中的响应信息，
           resp.setContentType("text/html");
           resp.setCharacterEncoding("UTF-8");
   
           PrintWriter writer = resp.getWriter();
           writer.print("<h1>这是404网页显示！！！</h1>");
       }
   
       @Override
       protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
           super.doPost(req, resp);
       }
   }
   ```

   - 在web.xml文件中加入这个映射！

   ```xml
     <!--404-->
     <servlet>
         <servlet-name>error</servlet-name>
         <servlet-class>com.kuang.servlet.ErrorServlet</servlet-class>
     </servlet>
     <servlet-mapping>
         <servlet-name>error</servlet-name>
         <url-pattern>/*</url-pattern>
     </servlet-mapping>
     
   
   ```

   - 效果展示

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211205115527.png)

—————————————————————————————————

**下面介绍Servlet中的一些典型对象**

—————————————————————————————————

### 6.5 ServletContext对象

web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用；

**一个trick：**

每一个java包下的web项目，都新建一个Tomcat服务器（并且删掉前面的，每次运行只保留一个）。



#### 1、共享数据

我在这个Servlet中保存的数据，可以在另外一个servlet中拿到；

- 创建第一个HelloServlet类，（其中有一个很重要的方法——**getServletContext()**，可以获取Servlet上下文；但是之前要先**setServletContext()**，设定Servlet的上下文）

```java
public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        
        //this.getInitParameter()   初始化参数
        //this.getServletConfig()   Servlet配置
        //this.getServletContext()  Servlet上下文
        ServletContext context = this.getServletContext();

        String username = "测试名字"; //数据
        context.setAttribute("username",username); //将一个数据保存在了ServletContext中，名字为：username 。值 username

    }

}
```

- 再创建一个GetServlet类

```java
public class GetServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext context = this.getServletContext();
        String username = (String) context.getAttribute("username");

        resp.setContentType("text/html");
        resp.setCharacterEncoding("utf-8");
        resp.getWriter().print("名字："+username);

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

- 把两个类都在xml中进行映射

```xml
    <servlet>
        <servlet-name>hello</servlet-name>
        <servlet-class>com.kuang.servlet.HelloServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>hello</servlet-name>
        <url-pattern>/hello</url-pattern>
    </servlet-mapping>

    <servlet>
        <servlet-name>getc</servlet-name>
        <servlet-class>com.kuang.servlet.GetServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>getc</servlet-name>
        <url-pattern>/getc</url-pattern>
    </servlet-mapping>
```

- <font size="5">**测试效果：**</font>

1. 直接访问/getc是没有的，返回的null
2. 先访问localhost:8080/s2/hello（把username放到web中），再访问localhost:8080/s2/getc就可以了

<img src="https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211205224027.png" style="zoom:50%;" />

#### 2、获取初始化参数

新建一个类ServletDemo3，准备调用xml中的初始化参数：

```java
public class ServletDemo3 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext context = this.getServletContext();
        String url = context.getInitParameter("url");
        resp.getWriter().print(url);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        super.doPost(req, resp);
    }
}
```

- xml中的初始化参数：

  - 引入ServletDemo3：

  ```xml
    <!--引入ServletDemo3-->
    <servlet>
      <servlet-name>gp</servlet-name>
      <servlet-class>com.kuang.servlet.ServletDemo3</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>gp</servlet-name>
      <url-pattern>/gp</url-pattern>
    </servlet-mapping>
  ```

  - 写入初始化参数：

  ```xml
    <!--配置一些web应用初始化参数-->
    <context-param>
      <param-name>url</param-name>
      <param-value>jdbc:mysql://localhost:3306/mybatis</param-value>
    </context-param>
  ```
**测试结果：**

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211205224221.png)

#### 3、请求转发

- 新建一个ServletDemo4：

```java
public class ServletDemo4 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext context = this.getServletContext();
        System.out.println("进入了ServletDemo04");
        //RequestDispatcher requestDispatcher = context.getRequestDispatcher("/gp"); //转发的请求路径
        //requestDispatcher.forward(req,resp); //调用forward实现请求转发；
        context.getRequestDispatcher("/gp").forward(req,resp);

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        super.doPost(req, resp);
    }
}
```

- 同样地，在web.xml中加入映射：

```xml
<!--引入ServletDemo4-->
<servlet>
  <servlet-name>sd4</servlet-name>
  <servlet-class>com.kuang.servlet.ServletDemo4</servlet-class>
</servlet>
<servlet-mapping>
  <servlet-name>sd4</servlet-name>
  <url-pattern>/sd4</url-pattern>
</servlet-mapping>
```

- 测试效果：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211205224838.png)

#### 4、读取资源文件（resources）

Properties类

- 在java目录下新建properties
- 在resources目录下新建properties（dp.properties）

发现：resources下的properties（不需要在该项目的pom.xml中配置<font size= "4" color = "red">(不是web.xml中，也不是最外围的pom.xml)</font>）、和java-main包下的properties（需要在pom.xml中配置）都被打包到了同一个路径下：classes，我们俗称这个路径为classpath:

配置方法：在xml中的<build></build>范围内写入：

```xml
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
                <filtering>true</filtering>
            </resource>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
                <filtering>true</filtering>
            </resource>
        </resources>
```



1. resources目录下新建一个文件流db.properties

```d
username=root12312
password=zxczxczxc
```

2. 新建一个ServletDemo5：

```java
public class ServletDemo5 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        InputStream is = this.getServletContext().getResourceAsStream("/WEB-INF/classes/db.properties");		//访问文件流
        Properties prop = new Properties();
        prop.load(is);  //读取文件流，标准的，都是这样读
        String user = prop.getProperty("username");
        String pwd = prop.getProperty("password");

        resp.getWriter().print(user+"----\n"+pwd);

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        super.doPost(req, resp);
    }
```

3. 在web.xml中加入映射：

```java
  <!--引入ServletDemo5-->
  <servlet>
    <servlet-name>sd5</servlet-name>
    <servlet-class>com.kuang.servlet.ServletDemo5</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>sd5</servlet-name>
    <url-pattern>/sd5</url-pattern>
  </servlet-mapping>

```

4. 测试效果：

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211206100247.png)



### 6.6-6.7：servlet处理数据的两个关键类`HttpServletRequest req, HttpServletResponse resp`

web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest
对象，代表响应的一个HttpServletResponse；

- 如果要获取客户端请求过来的参数：找HttpServletRequest
- 如果要给客户端响应一些信息：找HttpServletResponse

#### 1、简单分类

负责向浏览器发送数据的方法:getOutputstream();getwriter();

```java
 servletOutputstream getOutputstream() throws IOException;
    Printwriter getwriter() throws IOException;
```

负责向浏览器发送响应头的方法:其中经常用的是setCharacterEncoding（设置编码utf-8）；setContentType（设置发送到客户端的响应的内容类型，text/html , text/plain等）；

```java
void setCharacterEncoding(String var1)；
void setContentLength(int var1)；
void setContentLengthLong(long var1);
void setContentType(String var1)；
void setDateHeader(String varl,long var2)
void addDateHeader(String var1,long var2)
void setHeader(String var1,String var2);
void addHeader(String var1,String var2)；
void setIntHeader(String var1,int var2);
void addIntHeader(String varl,int var2);
```

响应的状态码：

- http状态返回代码 1xx（临时响应）
- http状态返回代码 2xx （成功）
- http状态返回代码 3xx （重定向）
- http状态返回代码 4xx（请求错误）
- http状态返回代码 5xx（服务器错误）

### 6.6 HttpServletRequest——servlet请求类

HttpServletRequest代表客户端的请求,用户通过Http协议访问服务器, HTTP请求中的所有信息会被封装到HttpServletRequest,通过这个HttpServletRequest的方法,获得客户端的所有信息;

- 注意：他没有太多的操作方法，基本都是在response中；一般这里都用于获取信息；

- 有一个转发的方法要注意：（转发的时候不用写到工程目录，'/'就代表了当前目录；重定向需要写出来主目录'/r/xxx';

```java
	//通过请求转发
	//这里的/代表当前的web应用
req.getRequestDispatcher("/success.jsp").forward(req,resp);
```





### 6.7 HttpServletResponse——servlet响应类

#### 1. **下载文件**

1. 向浏览器输出消息（一直在讲，就不说了）
2. 下载文件
   1. 要获取下载文件的路径
   2. 下载的文件名是啥？
   3. 设置想办法让浏览器能够支持下载我们需要的东西
   4. 获取下载文件的输入流
   5. 创建缓冲区
   6. 获取OutputStream对象
   7. 将FileOutputStream流写入到bufer缓冲区
   8. 使用OutputStream将缓冲区中的数据输出到客户端！

创建一个新的类Fileservlet：

```java
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    // 1.1 要获取下载文件的路径：不写死；路径不对，是Tomcat的webapps/1.png，变成了Tomcat的原始配置文件
    String realpath = this.getServletContext().getRealPath("/1.png");
    
    // 1.2 要获取下载文件的路径：写死；
    String realPath = "F:\\班级管理\\西开【19525】\\2、代码\\JavaWeb\\javaweb-02-servlet\\response\\target\\classes\\秦疆.png";

    
    System.out.println("下载文件的路径："+realPath);
    // 2. 下载的文件名是啥？
    String fileName = realPath.substring(realPath.lastIndexOf("\\") + 1);
    // 3. 设置想办法让浏览器能够支持(Content-Disposition)下载我们需要的东西,中文文件名URLEncoder.encode编码，否则有可能乱码
    resp.setHeader("Content-Disposition","attachment;filename="+URLEncoder.encode(fileName,"UTF-8"));
    // 4. 获取下载文件的输入流
    FileInputStream in = new FileInputStream(realPath);
    // 5. 创建缓冲区
    int len = 0;
    byte[] buffer = new byte[1024];
    // 6. 获取OutputStream对象
    ServletOutputStream out = resp.getOutputStream();
    // 7. 将FileOutputStream流写入到buffer缓冲区,使用OutputStream将缓冲区中的数据输出到客户端！
    while ((len=in.read(buffer))>0){
        out.write(buffer,0,len);
    }

    in.close();
    out.close();
}
```

#### 2. **验证码功能**

验证怎么来的? 

- ​	前端实现
- 后端实现，需要用到Java的图片类，生产一个图片

```java
package com.kuang.servlet;

import javax.imageio.ImageIO;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Random;

public class ImageServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        //如何让浏览器3秒自动刷新一次;
        resp.setHeader("refresh","3");
        
        //在内存中创建一个图片
        BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);
        //得到图片
        Graphics2D g = (Graphics2D) image.getGraphics(); //笔
        //设置图片的背景颜色
        g.setColor(Color.white);
        g.fillRect(0,0,80,20);
        //给图片写数据
        g.setColor(Color.BLUE);
        g.setFont(new Font(null,Font.BOLD,20));
        g.drawString(makeNum(),0,20);

        //告诉浏览器，这个请求用图片的方式打开
        resp.setContentType("image/jpeg");
        //网站存在缓存，不让浏览器缓存，下面三个都是的，选一个就行
        resp.setDateHeader("expires",-1);
        resp.setHeader("Cache-Control","no-cache");
        resp.setHeader("Pragma","no-cache");

        //把图片写给浏览器，IO类，专门写图片的
        ImageIO.write(image,"jpg", resp.getOutputStream());

    }

    //生成随机数
    private String makeNum(){
        Random random = new Random();
        String num = random.nextInt(9999999) + "";
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < 7-num.length() ; i++) {
            sb.append("0");
        }
        num = sb.toString() + num;
        return num;
    }


    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

#### 3. <font color = "red">**重定向（重点！！！）**</font>

常见场景:

- 用户登录`void sendRedirect(String var1) throws IOException;`

注册一个新的servlet项目：

```java
@override
protected void doGet(HttpservletRequest req, HttpservletResponse resp) throws ServletException, IOException {

    resp. sendRedirect("/r/img");//重定向到localhost:8080/r/img;要加上项目名称（/r）
    /*
    resp. setHeader("Location","/r/img");
    resp. setstatus (302);		//重定向的状态码
    *
}
```

#### 4、一个面试题：重定向和转发的区别？

1、 相同点：页面都会实现跳转；

2、 不同点：请求转发的时候，url不会变化(响应码307)；重定向的时候，url地址变(响应码302);

#### 5、一个前端登录的Demo

- 向总项目的pom.xml导入jar包：

```xml
    <dependencies>
    <!-- https://mvnrepository. com/artifact/javax. servLet/javax. servlet-opi -->
    <dependency>
    <groupld>javax.servlet</grouptd>
    <artifactId>javax. servlet-api</artifactId>
    <version>4.0.1</version>
    </dependency>
    <!-- https://mvnrepository.com/artifact/javax. servLet.jsp/javax. servLet.jsp-opi -->
    <dependency>
    <groupId>javax.servlet.jsp</groupld>
    <artifactId>javax. servlet.jsp-api</artifactId>
    <version>2.3.3</version>
    </dependency>
    </dependencies>
    </project>
```

- 在子项目中配置index.jsp：${pageContext. request, contextPath}一个技巧，代表当前的项目。在浏览器中接受到get请求（method="get"）。

```jsp
<html>
	<body>
		<h2>Hel1o World!</h2>
		
		《%--这里超交的路径,需要寻找到项目的路径--%>
		<%--${pageContext. request, contextPath}代表当前的项目--%>
		<form action="${pageContext. request.contextPath}/login" method="get">
			用户名: <input type="text" name="username"> <br>
			密码: <input type="password" name="password"> <br>
			<input type="submit">
		</form>
	
	</body>
</html>
```

创建一个RequestTest.java类

```java
public class RequestTest extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    //处理方求
    String username = req.getParameter( s: "username");
    String password  rea.getParameter( s: "password");

    System.out.println(username+":"+password);
	//注意路径问题。
    resp.sendRedirect(s: "/r/success.jsp");//重定向到新的文件
}
```

- 重定向页面success.jsp

```jsp
<%@ page contentType="text/html; charset=UTF-8" language="java" %>
<html>
    <head>
	    <title>Title</title>
	    </head>
    <body>
    	<h1>success</h1>
    </body>
</html>
```

在子项目的web.xml中加入映射：

```xml
<servlet>
<servlet-name>requset</servlet-name>
<servlet-class>com. kuang. servlet. RequestTest</servlet-class>
</servlet>
<servlet-mapping>
<servlet-name>requset</servlet-name>
<url-pattern>/login</url-pattern>
</servlet-mapping>
```

## 7、Cookie&Session

#### 7.1、会话

- 会话：用户打开一个浏览器，点击了很多超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话；

- **有状态会话：**一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过，称之为有状态会话；

**问题：你能怎么证明你是西开的学生？**

你 西开

- 发票 西开给你发票

- 学校登记 西开标记你来过了



**一个网站，怎么证明你来过？**

客户端 服务端

- 服务端给客户端一个 信件，客户端下次访问服务端带上信件就可以了； cookie
- 服务器登记你来过了，下次你来的时候我来匹配你； seesion

#### 7.2、保存会话的两种技术

##### **cookie**

- 客户端技术 （响应，请求）

##### **session**

- 服务器技术，利用这个技术，可以保存用户的会话信息？ 我们可以把信息或者数据放在Session中！

常见常见：网站登录之后，你下次不用再登录了，第二次访问直接就上去了！

#### 7.3、Cookie

1. 从请求中拿到cookie信息
2. 服务器响应给客户端cookie

```java
Cookie[] cookies = req.getCookies(); //获得Cookie
cookie.getName(); //获得cookie中的key
cookie.getValue(); //获得cookie中的vlaue
new Cookie("lastLoginTime", System.currentTimeMillis()+""); //新建一个cookie
cookie.setMaxAge(24*60*60); //设置cookie的有效期
resp.addCookie(cookie); //响应给客户端一个cookie
```

**cookie：一般会保存在本地的 用户目录下 appdata；**

#### 7.4 Session

什么是Session：

- 服务器会给每一个用户（浏览器）创建一个Seesion对象；
- 一个Seesion独占一个浏览器，只要浏览器没有关闭，这个Session就存在；
- 用户登录之后，整个网站它都可以访问！–> 保存用户的信息；保存购物车的信息……

**Session和cookie的区别：**

- Cookie是把用户的数据写给用户的浏览器，浏览器保存 （可以保存多个）
- Session把用户的数据写到用户独占Session中，服务器端保存 （保存重要的信息，减少服务器资源的浪费）
- Session对象由服务创建；

**Session使用场景：**

- 保存一个登录用户的信息；
- 购物车信息；
- 在整个网站中经常会使用的数据，我们将它保存在Session中；

##### 使用Session

```java
package com.kuang.servlet;

import com.kuang.pojo.Person;

import javax.servlet.ServletException;
import javax.servlet.http.*;
import java.io.IOException;

public class SessionDemo01 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        
        //解决乱码问题
        req.setCharacterEncoding("UTF-8");
        resp.setCharacterEncoding("UTF-8");
        resp.setContentType("text/html;charset=utf-8");
        
        //得到Session
        HttpSession session = req.getSession();
        //给Session中存东西
        session.setAttribute("name",new Person("秦疆",1));
        //获取Session的ID
        String sessionId = session.getId();

        //判断Session是不是新创建
        if (session.isNew()){
            resp.getWriter().write("session创建成功,ID:"+sessionId);
        }else {
            resp.getWriter().write("session以及在服务器中存在了,ID:"+sessionId);
        }

        //Session创建的时候做了什么事情；1.先拿到一个sessionID，放到cookie中；2.这个sessionID放到了JESSIONID。
//        Cookie cookie = new Cookie("JSESSIONID",sessionId);
//        resp.addCookie(cookie);

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

##### 几个关键方法

```java
//得到Session
HttpSession session = req.getSession();

Person person = (Person) session.getAttribute("name");

System.out.println(person.toString());

HttpSession session = req.getSession();
session.removeAttribute("name");
//手动注销Session
session.invalidate();
```





## ~~8、JSP（前端这部分先跳过，伴随项目学习）~~

基本的描述语言，JS + HTML

### 8.1、什么是JSP

Java Server Pages ： Java服务器端页面，也和Servlet一样，用于动态Web技术！

最大的特点：

- 写JSP就像在写HTML
- 区别：
  - HTML只给用户提供静态的数据
  - JSP页面中可以嵌入JAVA代码，为用户提供动态数据；

### 8.2、JSP原理

思路：JSP到底怎么执行的！

- 代码层面没有任何问题

- 服务器内部工作

  tomcat中有一个work目录；

  IDEA中使用Tomcat的会在IDEA的tomcat中生产一个work目录

**浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet！**

JSP最终也会被转换成为一个Java类！

**JSP 本质上就是一个Servlet**



## 9、JavaBean

JavaBean 是特殊的 Java 类，使用 Java 语言书写，并且遵守 JavaBean API 规范。（**JavaBean是一个遵循特定写法的Java类**），一般在项目中，位于`com.xxx.pojo`（或者`com.xxx.entity`）中。

接下来给出的是 JavaBean 与其它 Java 类相比而言独一无二的特征：

- 提供一个默认的无参构造函数。
- 需要被序列化并且实现了 Serializable 接口。
- 可能有一系列可读写属性。
- 可能有一系列的 getter 或 **setter** 方法。

#### 作用

一般用来和数据库的字段做映射 ORM；

ORM ：对象关系映射

- 表—>类
- 字段–>属性
- 行记录---->对象

比如一个people表：

| id   | name    | age  | address |
| ---- | ------- | ---- | ------- |
| 1    | 秦疆1号 | 3    | 西安    |
| 2    | 秦疆2号 | 18   | 西安    |
| 3    | 秦疆3号 | 100  | 西安    |



```java
//实体类，一般和数据库中的表结构一一对应！！
class People{
    private int id;
    private String name;
    private int id;
    private String address;
}

class A{
    new People(1,"秦疆1号",3，"西安");
    new People(2,"秦疆2号",3，"西安");
    new People(3,"秦疆3号",3，"西安");
}
```

在最下面的目录中创建javabean.jsp：

```jsp
<jsp:useBean id="people" class=" com. kuang. pojo. People" scope= "page"/>
<jsp:setProperty name=" people" property="address" value="西安"/>
<jsp:setProperty name=" people" property="id" value="1"/>
<jsp:setProperty name=" people" property="age'
value="3"/>
<jsp:setProperty name=' people" property="name" value="小狂神呀"/>
姓名: <jsp:getProperty name=" people"
property="name"/>
id: <jsp: getProperty name="people" property="id"/>
年龄: <jsp:getProperty name=" people"
property= " age" />
地址: <jsp:getProperty name= "people" property=" address"/>

```

就相当于在java类中做set方法和get方法：

```java
People people = new People(); 
people.setAddress();
people.setId0);
people.setAge();
people.setName();
```



## 10、MVC三层架构

什么是MVC： 

- Model  —— 模型(实体类和数据库中一个个的字段)
- view —— 视图（jsp页面）
- Controller —— 控制器（servlet）

### 10.1 以前的架构（要么走jsp，要么走servlet）

![(img-NGdCSHqw-1588757845418)(JavaWeb.assets/1568423664332.png)](https://img-blog.csdnimg.cn/20200508154442187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70)

jsp就是一个servlet！————为了区分：Servlet和Jsp都可以写Java代码;

- Servlet专注于处理请求，以及控制视图跳转
- JSP专注于显示数据

<font size = '5'>**总结：**</font>

早前的结构，servlet直接操作javaBean。用户直接访问控制层，控制层就可以直接操作数据库。

```text
servlet--CRUD-->数据库
弊端：程序十分臃肿，不利于维护  
servlet的代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码

架构：没有什么是加一层解决不了的！比如：
				程序猿调用
					↑↑
			JDBC （实现该接口）
					↑↑
	Mysql Oracle SqlServer ....（不同厂商）
```



### 10.2、MVC三层架构

![[(img-BWDJGUCN-1588757845419)(JavaWeb.assets/1568424227281.png)]](https://img-blog.csdnimg.cn/20200508154512751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70)

**Model**

- 业务处理 ：业务逻辑（Service）
- 数据持久层：CRUD （Dao - 数据持久化对象）

**View**

- 展示数据
- 提供链接发起Servlet请求 （a，form，img…）

**Controller （Servlet）**

- 接收用户的请求 ：（req：请求参数、Session信息….）
- 交给业务层处理对应的代码
- 控制视图的跳转

**举个例子：**

```text
登录--->（来了个业务）

接收用户的登录请求--->

处理用户的请求（获取用户登录的参数，username，password）---->（调用相关的services）

交给业务层处理登录业务（判断用户名密码是否正确：事务）--->（相应的services）

Dao层查询用户名和密码是否正确-->

数据库

```



## 11、Filter（重点）

比如 Shiro安全框架技术就是用Filter来实现的

**Filter：过滤器 ，用来过滤网站的数据；**

- 处理中文乱码
- 登录验证….

（比如用来过滤网上骂人的话，我***我自己 0-0）

![(img-QEq74VyV-1588757845420)(JavaWeb.assets/1568424858708.png)](https://img-blog.csdnimg.cn/20200508154536177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70)

### Filter开发步骤

1. **在该项目的pom.xml导入依赖包**

```xml
<dependencies>
    <!--Servlet依赖-->
    <dependency>
        <groupId>javax. serv1et</ groupId>
        <artifactId>servlet-api</artifactId>
        <version>2.5</version>
    </ dependency>
    <!--JSP依赖-->
    <dependency>
        <groupId>javax . servlet .jsp</groupId>
        <artifactId>javax. . servlet. jsp-api</artifactId>
        <version>2.3.3</version>
    </ dependency>
    <!-- JSTL表达式的依赖-->
    <dependency>
        <groupId>javax . servlet .jsp . jst1</ groupId>
        <artifactId>jstl-api</artifactId>
        <version>1.2</version>
    </ dependency>
    <!-- standard标签库-->
    <dependency>
        <groupId>taglibs</ groupId>
        <artifactId>standard</ artifactId>
        <version>1.1.2</version>
        
        
     <!--连接数据库--> 
    <dependency>
        <groupId>mysq1</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>5.1.47</version>
    </ dependency>

</ dependency>

```

2. **编写过滤器**——实现Filter接口，重写对应的方法即可（实现的接口是javax.servlet的Filter类，不要搞错（有很多同名的包））

```java
      public class CharacterEncodingFilter implements Filter {
      
          //初始化：web服务器启动，就以及初始化了，随时等待过滤对象出现！
          public void init(FilterConfig filterConfig) throws ServletException {
              System.out.println("CharacterEncodingFilter初始化");
          }
      
          //Chain : 链
          /*
          1. 过滤中的所有代码，在过滤特定请求的时候都会执行
          2. 必须要让过滤器继续通行
              chain.doFilter(request,response);
           */
          public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
              request.setCharacterEncoding("utf-8");
              response.setCharacterEncoding("utf-8");
              response.setContentType("text/html;charset=UTF-8");
      
              System.out.println("CharacterEncodingFilter执行前....");
              chain.doFilter(request,response); //让我们的请求继续走，如果不写，程序到这里就被拦截停止！
              System.out.println("CharacterEncodingFilter执行后....");
          }
      
          //销毁：web服务器关闭的时候，过滤器会销毁
          public void destroy() {
              System.out.println("CharacterEncodingFilter销毁");
          }
      }
```

3. **在web.xml中配置 Filter**（和servlet一样的配置）

```xml
   <filter>
       <filter-name>CharacterEncodingFilter</filter-name>
       <filter-class>com.kuang.filter.CharacterEncodingFilter</filter-class>
   </filter>
   <filter-mapping>
       <filter-name>CharacterEncodingFilter</filter-name>
       <!--只要是 /servlet的任何请求，会经过这个过滤器-->
       <url-pattern>/servlet/*</url-pattern>
       <!--<url-pattern>/*</url-pattern>-->
       <!-- 别偷懒写个 /* -->
   </filter-mapping>

```





## 12、监听器（listener）

实现一个监听器的接口；（有n种监听器）

1. 编写一个监听器

   实现监听器的接口…

![依赖的jar包](https://img-blog.csdnimg.cn/2020050820562995.png)

**例如：统计网站在线人数  = 统计session**

2. **编写一个监听器类**

```java
//统计网站在线人数 ： 统计session
public class OnlineCountListener implements HttpSessionListener {

    //创建session监听： 看你的一举一动
    //一旦创建Session就会触发一次这个事件！
    public void sessionCreated(HttpSessionEvent se) {
        ServletContext ctx = se.getSession().getServletContext();

        System.out.println(se.getSession().getId());

        Integer onlineCount = (Integer) ctx.getAttribute("OnlineCount");

        if (onlineCount==null){
            onlineCount = new Integer(1);
        }else {
            int count = onlineCount.intValue();
            onlineCount = new Integer(count+1);
        }

        ctx.setAttribute("OnlineCount",onlineCount);

    }

    //销毁session监听
    //一旦销毁Session就会触发一次这个事件！
    public void sessionDestroyed(HttpSessionEvent se) {
        ServletContext ctx = se.getSession().getServletContext();

        Integer onlineCount = (Integer) ctx.getAttribute("OnlineCount");

        if (onlineCount==null){
            onlineCount = new Integer(0);
        }else {
            int count = onlineCount.intValue();
            onlineCount = new Integer(count-1);
        }

        ctx.setAttribute("OnlineCount",onlineCount);

    }

}
```



Session销毁：   

- 手动销毁  getSession().invalidate();    
- 自动销毁   



3. 编写在线网页index.jsp

```jsp
<%@ page contentType="text/html ;charset=UTF-8" language="java" %>
<html>
    <head>
        <title>$Title$</title>
    </head>
    <body>
    <h1>当前有<span><%=this. getServ1etCpnfig( . getServ1etContext().getAttribute("onlineCount")%></span>人在线</h1>
    </body>
</html>

```



4. 在web.xml中注册监听器

```xml
<!--注册监听器-->
<listener>
    <listener-class>com.kuang.listener.OnlineCountListener</listener-class>
</listener>
```



## 13、过滤器、监听器常见应用

### 13.1 **监听器：GUI编程中经常使用；**

1. 新建一个类

```java
public class TestPanel {
    public static void main(String[] args) {
        Frame frame = new Frame("中秋节快乐");  //新建一个窗体
        Panel panel = new Panel(null); //面板
        frame.setLayout(null); //设置窗体的布局

        frame.setBounds(300,300,500,500);
        frame.setBackground(new Color(0,0,255)); //设置背景颜色

        panel.setBounds(50,50,300,300);
        panel.setBackground(new Color(0,255,0)); //设置背景颜色

        frame.add(panel);

        frame.setVisible(true);

        //监听事件，监听关闭事件。如果没有，这个程序点关闭其实是关闭不了的，只能是一个java程序。
        frame.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                super.windowClosing(e);
            }
        });

    }
}
```

### 13.2 Filter实现权限拦截

用户登录之后才能进入主页！用户注销后就不能进入主页了！

1. 用户登录之后，向Sesison中放入用户的数据
2. 进入主页的时候要判断用户是否已经登录；要求：在过滤器中实现！

```java
HttpServletRequest request = (HttpServletRequest) req;
HttpServletResponse response = (HttpServletResponse) resp;

if (request.getSession().getAttribute(Constant.USER_SESSION)==null){
    response.sendRedirect("/error.jsp");
}

chain.doFilter(request,response);
```



## 14、JDBC（Java database connector）

什么是JDBC ： Java连接数据库！

![[(img-rZzTXmtn-1588757845422)(JavaWeb.assets/1568439601825.png)]](https://img-blog.csdnimg.cn/20200508154620734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70)

**需要jar包的支持：**

- java.sql
- javax.sql
- mysql-connector-java… 连接驱动（必须要导入）



### 14.1、 **实验环境搭建**

#### 1. 导入数据库依赖（不同版本的数据库依赖有差别，可以在网上找）

```xml
    <dependencies>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.11</version>
        </dependency>
    </dependencies>
```

#### 2. 新建一个Mysql数据库

```sql

CREATE TABLE users(
    id INT PRIMARY KEY,
    `name` VARCHAR(40),
    `password` VARCHAR(40),
    email VARCHAR(60),
    birthday DATE
);

INSERT INTO users(id,`name`,`password`,email,birthday)
VALUES(1,'张三','123456','zs@qq.com','2000-01-01');
INSERT INTO users(id,`name`,`password`,email,birthday)
VALUES(2,'李四','123456','ls@qq.com','2000-01-01');
INSERT INTO users(id,`name`,`password`,email,birthday)
VALUES(3,'王五','123456','ww@qq.com','2000-01-01');
```

#### 3.IDEA中链接并配置数据库

3.1 idea右边database点击“+”；

3.2 选中“mysql“，第一次配需要顺带配置driver驱动（自动的选好的）；

<img src="https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211210103047.png" style="zoom:50%;" />

3.3 配置mysql登录，选中创建的表

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211210103203.png)

#### 4.新建一个java类，链接并操作数据库

```java
public class TestJdbc {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        //配置信息
        //useUnicode=true&characterEncoding=utf-8 解决中文乱码
        String url="jdbc:mysql://localhost:3306/jdbc?useUnicode=true&characterEncoding=utf-8";
        String username = "root";
        String password = "123456";

        //1.加载驱动
        Class.forName("com.mysql.jdbc.Driver");
        //2.连接数据库,代表数据库
        Connection connection = DriverManager.getConnection(url, username, password);

        //3.向数据库发送SQL的对象Statement,PreparedStatement : CRUD
        Statement statement = connection.createStatement();

        //4.编写SQL
        String sql = "select * from users";

        //5.执行查询SQL，返回一个 ResultSet  ： 结果集
        ResultSet rs = statement.executeQuery(sql);

        while (rs.next()){
            System.out.println("id="+rs.getObject("id"));
            System.out.println("name="+rs.getObject("name"));
            System.out.println("password="+rs.getObject("password"));
            System.out.println("email="+rs.getObject("email"));
            System.out.println("birthday="+rs.getObject("birthday"));
        }

        //6.关闭连接，释放资源（一定要做） 先开后关
        rs.close();
        statement.close();
        connection.close();
    }
}
```

#### **小结：JDBC一般流程**

1. 加载驱动
2. 连接数据库,代表数据库
3. 向数据库发送SQL的对象Statement : CRUD
4. 编写SQL （根据业务，不同的SQL）
5. 执行SQL
6. 关闭连接（先开的后关）

#### 5. 预编译SQL（PreparedStatement：CURD）

```java
public class TestJDBC2 {
    public static void main(String[] args) throws Exception {
        //配置信息
        //useUnicode=true&characterEncoding=utf-8 解决中文乱码
        String url="jdbc:mysql://localhost:3306/jdbc?useUnicode=true&characterEncoding=utf-8";
        String username = "root";
        String password = "123456";

        //1.加载驱动
        Class.forName("com.mysql.jdbc.Driver");
        //2.连接数据库,代表数据库
        Connection connection = DriverManager.getConnection(url, username, password);

        //3.编写SQL
        String sql = "insert into  users(id, name, password, email, birthday) values (?,?,?,?,?);";

        //4.预编译
        PreparedStatement preparedStatement = connection.prepareStatement(sql);

        preparedStatement.setInt(1,2);//给第一个占位符？ 的值赋值为1；
        preparedStatement.setString(2,"狂神说Java");//给第二个占位符？ 的值赋值为狂神说Java；
        preparedStatement.setString(3,"123456");//给第三个占位符？ 的值赋值为123456；
        preparedStatement.setString(4,"24736743@qq.com");//给第四个占位符？ 的值赋值为1；
        preparedStatement.setDate(5,new Date(new java.util.Date().getTime()));//给第五个占位符？ 的值赋值为new Date(new java.util.Date().getTime())；

        //5.执行SQL
        int i = preparedStatement.executeUpdate();

        if (i>0){
            System.out.println("插入成功@");
        }

        //6.关闭连接，释放资源（一定要做） 先开后关
        preparedStatement.close();
        connection.close();
    }
}
```

- 绝大多数情况下，某需求某一条 SQL 语句可能会被反复调用执行，或者每次执行的时候只有个别的值不同（比如 select 的 where 子句值不同，update 的 set 子句值不同，insert 的 values 值不同）。如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显不行了。
- 所谓预编译语句就是将此类 SQL 语句中的值用占位符替代，可以视为将 SQL 语句模板化或者说参数化，一般称这类语句叫Prepared Statements。　　
- 预编译语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程；此外预编译语句能防止 SQL 注入。



#### 事务

要么都成功，要么都失败！

- 保证数据的安全——ACID原则：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。

**一般流程：**

- 开启事务
- 事务提交  commit()
- 事务回滚  rollback()
- 关闭事务

**经典案例——转账**

1. A（1000块）给B（1000块）转100；
2. A转完还剩900，但是B还没收到时，服务器崩溃
3. 这时候钱是多少就无法确定了

### Junit单元测试

#### 1. 在pom.xml中加入junit的依赖

```xml
<!--单元测试-->
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.12</version>
</dependency>
```

#### 2. 简单使用

@Test注解只有在方法上有效，只要加了这个注解的方法，就可以直接运行！（以前需要在main方法中调用）——这样以后测试新写的方法的时候，就可以直接用这个了

```java
package com.kuang.test;

import org.junit.Test;

public class TestJdbc3 {

    @Test
    public void test(){
        System.out.println("hello");
        System.out.println(1/0);	//error
    }
}

```

#### 3. 测试效果

![](https://raw.githubusercontent.com/BBQldf/PicGotest/master/20211210110923.png)



### 搭建一个环境，测试一个事务

#### 1. mysql创建一个新表

```mysql
CREATE TABLE account(
   id INT PRIMARY KEY AUTO_INCREMENT,
   `name` VARCHAR(40),
   money FLOAT
);

//插入三条数据
INSERT INTO account(`name`,money) VALUES('A',1000);
INSERT INTO account(`name`,money) VALUES('B',1000);
INSERT INTO account(`name`,money) VALUES('C',1000);
```

#### 2. 新建一个java类----操作和配置mysql数据库（带事务）

```java
package com.kuang.test;

import org.junit.Test;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class TestJdbc3 {
    @Test
    public void test() {
        //配置信息
        //useUnicode=true&characterEncoding=utf-8 解决中文乱码
        String url="jdbc:mysql://localhost:3306/jdbc?useUnicode=true&characterEncoding=utf-8&useSSL=false";
        String username = "root";
        String password = "123456";

        Connection connection = null;

        //1.加载驱动
        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
            //2.连接数据库,代表数据库
            connection = DriverManager.getConnection(url, username, password);

            //3.通知数据库开启事务,false 开启
            connection.setAutoCommit(false);

            String sql = "update account set money = money-100 where name = 'A'";
            connection.prepareStatement(sql).executeUpdate();

            //制造错误
            int i = 1/0;

            String sql2 = "update account set money = money+100 where name = 'B'";
            connection.prepareStatement(sql2).executeUpdate();

            connection.commit();//以上两条SQL都执行成功了，就提交事务！
            System.out.println("success");
        } catch (Exception e) {
            try {
                //如果出现异常，就通知数据库回滚事务
                connection.rollback();
            } catch (SQLException e1) {
                e1.printStackTrace();
            }
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

}
```

关键点：

1. 通知数据库开启事务,false 开启（是反过来的）——connection.setAutoCommit(false);
2. 用try-catch捕捉异常
